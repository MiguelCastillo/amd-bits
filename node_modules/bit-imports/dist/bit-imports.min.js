/*! bit-imports v1.0.2 - Sat Nov 14 2015 16:10:05. (c) 2015 Miguel Castillo. Licensed under MIT */
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.bitimports=a()}}(function(){var define,module,exports;return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){var d=a("promjax"),e=a("./src/fileReader");
// Register method to load file content from storage
e.register(d),
// Export bit imports!
b.exports=a("./src/bit-imports")},{"./src/bit-imports":46,"./src/fileReader":48,promjax:45}],2:[function(a,b,c){function d(a,b){this.url=new e(a,b)}var e=a("./url");/**
 * Build and file object with the important pieces
 */
d.parseParts=function(a){var b,c=a.replace(/([^/]+)$/gim,function(a){return b=a,""});return{name:b||"",directory:c,path:a}},/**
 * Method to add an extension if one does not exist in the fileString.  It does NOT replace
 * the file extension if one already exists in `fileString`.
 *
 * @param {string} fileString - File string to add the extension to if one does not exist
 * @param {string} extension - Extension to add if one does not exist in `fileString`. The
 *   value is the extension without the `.`. E.g. `js`, `html`.  Not `.js`, `.html`.
 * @returns {string} New fileString with the new extension if one did not exist
 */
d.addExtension=function(a,b){var c=d.parseParts(a),e=c.name.split(".");return 1===e.length&&b&&e.push(b),c.directory+e.join(".")},/**
 * Method that gets the extension from a file path
 *
 * @param {string} fileString - File path to get the extension for.
 *
 * @returns {string} File extension
 */
d.getExtension=function(a){var b=a.match(/[^.\/\\]+\.([^.]+)$/);return b&&b[1]||""},/**
 * Method to replace an extension, if one does not exist in the file string, it will be added.
 *
 * @param {string} fileString - File string to add the extension to if one does not exist
 * @param {string} extension - Extension to be either added to `fileString` or to replace the extension in `fileString`. The
 *   value is the extension without the `.`. E.g. `js`, `html`.  Not `.js`, `.html`.
 * @returns {string} fileString with the new extension
 */
d.replaceExtension=function(a,b){var c=/([^.\/\\]+\.)[^.]+$/;return c.test(a)?a.replace(c,"$1"+b):a+"."+b},b.exports=d},{"./url":4}],3:[function(a,b,c){/**
 * @constructor
 * Provides a way to build a module meta object from a module name.  The resolution
 * relies on configuration settings, which are compatible with requirejs. The created
 * module meta objects contain information such as a url that can be used for downloading
 * the corresponding file from a remote sever.
 */
function d(a){a=a||{};var b=a.baseUrl||".";
// Make sure that if a baseUrl is provided, it ends in a slash.  This is to ensure
// proper creation of URLs.
b&&"/"!==b[b.length-1]&&(b+="/");for(var c in g)this[c]=a.hasOwnProperty(c)?a[c]:g[c];this.baseUrl=b}var e=a("./file"),f=a("./url"),g={urlArgs:"",shim:{},packages:[],paths:{},extensions:[]};/**
 * Creates a module meta from a module name/id.
 *
 * @param {string} name - Module name/id
 * @param {string} baseUrl - base url to be used when the `name` starts with `./`, `../`, or a protocol.
 *   Otherwise the configured baseUrl is used.
 *
 * @returns {{name: string, file: File, urlArgs: string, shim: object}}
 */
d.prototype.resolve=function(a,b){var c,f,g,h,i,j,k,l,m,n=this.shim,o=this.packages,p=this.paths,q=p[a],r=a.split("!");
// Go through the packages and figure if the module is actually configured as such.
for(a=r.pop(),j=a.replace(/[\/\\]+/g,"/").split("/"),k=j.shift(),l=j.join("/"),c=0,f=o.length;f>c;c++){if(i=o[c],i===k){q=k+"/main";break}if(i.name===k){q=i.location&&i.location+"/"||"",q+=k+"/"+(l||i.main||"main");break}}
// Get the extension to determine if we need to add the `js` extension or not.
// Let's assume .js extension for everything that is not for a plugin
// or a known extension
return n.hasOwnProperty(a)&&(m={name:n[a].exports||n[a].name||a,deps:n[a].imports||n[a].deps||[]}),q||(q=a),h=e.getExtension(q),0===r.length&&"js"!==h&&-1===this.extensions.indexOf(h)&&(q+=".js"),b=d.useBase(q)&&b?b:this.baseUrl,g=new e(this.urlArgs?q+"?"+this.urlArgs:q,b),{name:a,file:g,url:g.url,shim:m,plugins:r}},/**
 * Checks and returns true if name starts with `./`, `../`, or a protocol.  Otherwise returns false;
 */
d.useBase=function(a){return"."===a[0]&&("/"===a[1]||"."===a[1]&&"/"===a[2])||d.hasProtocol(a)},/**
 * Quick check to determine if the name has a known protocol. Currently we only support http(s) and file.
 */
d.hasProtocol=function(a){return/^(?:(https?|file)(:\/\/\/?))/g.test(a)},d.File=e,d.Url=f,b.exports=d},{"./file":2,"./url":4}],4:[function(a,b,c){/**
 * Url factory that creates URL object as defined here https://developer.mozilla.org/en-US/docs/Web/API/URL
 *
 * @param {urlString} string - URL string to build a URL object from
 * @param {baseString} string - URL string to use as a base for building the URL object.
 *
 * @returns {object} URL object
 */
function d(a,b){return d.parser.join(b||"",a)}/**
 * Parses out a url, with an optional base url, and returns the fully processed href.
 *
 * @param {string} urlString - URL to be processed
 * @param {string} baseString - Base URL
 *
 * @returns {string} full href
 */
function e(a,b){return d.parser.join(a,b).href}/**
 * Parses out a url string with an optional base url, and returns the fully resolved URL object.
 *
 * @param {string} urlString - URL to be processed
 * @param {string} baseString - Base URL
 *
 * @returns {object} URL object
 */
function f(a,b){var c=g(a),d=g(b),e="";return i.isAbsolute(d.pathname)?e=d.pathname:(c.pathname||d.pathname)&&(e=i.join(h(c.pathname),d.pathname)),!d.hostname&&c.hostname&&(d=c),d.pathname=e,d.href=g.href(d),d}/**
 * Parses out a string and creates a URL object as defined
 * here https://developer.mozilla.org/en-US/docs/Web/API/URL
 *
 * Parses out the username and password from a URL as defined here.
 * https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/username
 * https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/password
 *
 * @param {string} urlString - URL string to be parsed to create a URL object
 * @returns {object} URL object
 */
function g(a){var b=/^((https?:)(\/\/\/?)(?:([\w]+)(?::([\w]*))?@)?([\d\w\.-]+)(?::(\d+))?)?([\/\\\w\.()-]*)?(?:([?][^#]*)?(#.*)?)*/gim.exec(a);b.shift(),
// Make sure we sanitize the slashes and dotted paths
b[5]&&(b[5]=i.normalize(b[5]));var c={origin:b[0]||"",protocol:b[1]||"",delimeter:b[2]||"",username:b[3]||"",password:b[4]||"",hostname:b[5]||"",port:b[6]||"",pathname:b[7]||"",search:b[8]||"",hash:b[9]||""};return c.pathname=g.pathname(c),c.host=g.host(c),c.href=g.href(c),c}/**
 * Processes a pathname and returns only the path. If a file is present
 * then it is removed, otherwise the same string is returned.
 *
 * @returns {string} directory of the pathname
 */
function h(a){return 1!==a.length&&"/"!==a[a.length-1]?a.substr(0,a.lastIndexOf("/")):a}var i=a("path");/**
 * Parses out the pathname based on whether or not a hostname exists. If a
 * hostname exists then there must always be a path; "/" by default. Otherwise
 * pathname can be empty.
 *
 * @param {object} url - URL object
 * @returns {string} pathname
 */
g.pathname=function(a){return a.hostname?a.pathname||"/":a.pathname},/**
 * Builds a host string.  The host string is defined as the hostname, and if a port
 * is specified, then a ":" and the port number.  Otherwise just the hostname.
 *
 * @param {object} url - URL object
 * @returns {string} Host string
 */
g.host=function(a){return a.hostname+(a.port?":"+a.port:"")},/**
 * Builds the full URL as a string
 *
 * @param {object} url - URL object
 * @returns {string} Full url as a string
 */
g.href=function(a){return a.origin+a.pathname+a.search+a.hash},d.parser={resolve:e,parse:g,join:f},
//
// This chunk of code below enables nodejs URL module.  Useful for testing purposes.
//
//Url.parser = require('url');
//Url.parser.join = function(baseString, urlString) {
//  var resolved = Url.parser.resolve(baseString || "", urlString);
//  var url      = Url.parser.parse(resolved);
//  url.origin   = url.protocol ? (url.protocol + "//" + url.host) : "";
//  url.hash     = url.hash     || "";
//  url.host     = url.host     || "";
//  url.hostname = url.hostname || "";
//  url.password = url.password || "";
//  url.pathname = url.pathname || "";
//  url.port     = url.port     || "";
//  url.protocol = url.protocol || "";
//  url.search   = url.search   || "";
//  url.username = url.username || "";
//  return url;
//};
b.exports=d},{path:43}],5:[function(a,b,c){/**
 * Check if input is undefined
 *
 * @param {*} item - Item to be tested for undefined
 * @returns {boolean}
 */
function d(a){return void 0===a}/**
 * Check if input is null
 *
 * @param {*} item - Item to be tested for null
 * @returns {boolean}
 */
function e(a){return null===a}/**
 * Check if input is a regulat expression
 *
 * @param {*} item - Item to check for regular expression
 * @returns {boolean}
 */
function f(a){return!!a&&n(a)===o}/**
 * Check if input is a function
 *
 * @param {*} item - Item to be tested for function
 * @returns {boolean}
 */
function g(a){return"function"==typeof a}/**
 * Check if input is a string
 *
 * @param {*} item - Item to check for string
 * @returns {boolean}
 */
function h(a){return"string"==typeof a}/**
 * Check if input is an object. Objects are:
 *  - literal object, object instances, arrays, null
 *
 * @param {*} item - Item to check for object
 * @returns {boolean}
 */
function i(a){return"object"==typeof a}/**
 * Check if input is a Date
 *
 * @param {*} item - Item to be tested for Date
 * @returns {boolean}
 */
function j(a){return n(a)===p}/**
 * Check if item is an object literal - plain object.
 *
 * @param {*} item - Item to check for object literal
 * @returns {boolean}
 */
function k(a){return n(a)===r}/**
 * Check if input is an error
 *
 * @param {*} item - Item to check for error
 * @returns {boolean}
 */
function l(a){return n(a)===s||a instanceof Error}/**
 * Extract the type name. This uses Object.prototype.toString
 * to get the type name.
 *
 * @param {*} item - Item to get the type for
 * @returns {string} type of the object
 */
function m(a){return e(a)?"null":d(a)?"undefined":/\[.+ ([^\]]+)/.exec(n(a))[1].toLowerCase()}
// Helper method to test for object types.
var n=function(){var a=Object.prototype.toString;return function(b){return a.call(b)}}(),o=n(/test/),p=n(new Date),q=n([]),r=n({}),s=n(new Error),t=function(){return Array.isArray?Array.isArray:function(a){return n(a)===q}}();b.exports={isNull:e,isUndefined:d,isRegex:f,isArray:t,isError:l,isString:h,isObject:i,isPlainObject:k,isFunction:g,isDate:j,typeName:m,toString:n}},{}],6:[function(a,b,c){/**
 * Copies all properties from sources into target object. This is a
 * shallow copy.
 *
 * @param {object} target - Object to copy properties to
 * @param {...} rest - The rest of the arguments are merged into target
 *
 * @returns {object} Object with all arguments merged in.
 */
function d(a){var b,c,d;
// Allow n params to be passed in to extend this object
for(a=a||{},d=1,c=arguments.length;c>d;d++){b=arguments[d];for(var e in b)b.hasOwnProperty(e)&&(a[e]=b[e])}return a}b.exports=d},{}],7:[function(a,b,c){var d=a("./noop"),e=a("./result"),f=a("./pluck"),g=a("./extend"),h=a("./merge");b.exports={noop:d,result:e,pluck:f,extend:g,merge:h}},{"./extend":6,"./merge":8,"./noop":9,"./pluck":10,"./result":11}],8:[function(a,b,c){/**
 * Deep copy all properties into target object.
 *
 * @param {object} target - Object to copy properties to
 * @param {...} rest - The rest of the arguments are deeply merged into target
 *
 * @returns {object} Object with all arguments merged in.
 */
function d(a){var b,c,f,g=arguments;
// Allow `n` params to be passed in to extend this object
for(a=a||{},f=1,c=g.length;c>f;f++){b=g[f];for(var h in b)b.hasOwnProperty(h)&&(e.isPlainObject(b[h])?a[h]=d(a[h],b[h]):a[h]=b[h])}return a}var e=a("dis-isa");b.exports=d},{"dis-isa":5}],9:[function(a,b,c){/**
 * Noop method. You can pass in an argument and it will be returned as is.
 *
 * @param {*} arg - Argument to be returned. This is completely optional
 * @returns {*} This returns whatever is passed in.
 */
function d(a){return a}b.exports=d},{}],10:[function(a,b,c){/**
 * Method to extract data out of an Object.
 *
 * @param {*} input - Object to extract data from
 * @param {*} keys - Keys to extract data from input.
 *
 * @returns {*} If input is a function, then the result of calling it is
 *  returned. Otherwise args are processed to determine what is returned.
 *
 * If keys is a string, then it is used as is for extracting the value
 * out of input.
 *
 * If keys is an object, then all the keys and values are used for extracting
 * the values out of input.
 *
 * If keys is an array, then they are all used for extracting the values out
 * of input.
 */
function d(a,b){if(1!==arguments.length){if(e.isString(b))return a[b];if(e.isArray(b))return b.reduce(function(b,c){return b[c]=a[c],b},{});if(e.isPlainObject(b))return Object.keys(b).reduce(function(c,d){return a.hasOwnProperty(d)&&a[d]===b[d]&&(c[d]=a[d]),c},{})}return a}var e=a("dis-isa");b.exports=d},{"dis-isa":5}],11:[function(a,b,c){/**
 * Gracefully handle generating an output from an input. The input is an object
 * and if the property in the object is a function, then the function is called
 * and the result is returned. Otherwise, the value from `input[property]` is returned.
 *
 * @param {object} input - Object to read `property` from.
 * @param {string|number} property - Property to read from the `input` object
 * @param {array} data - Data to be passed to the when value is a function.
 * @param {*} context - Context used when value is a function.
 *
 * @returns {*} result of calling the function or property from input.
 */
function d(a,b,c,d){return e.isFunction(a[b])?a[b].apply(d,c||[]):a[b]}var e=a("dis-isa");b.exports=d},{"dis-isa":5}],12:[function(a,b,c){arguments[4][5][0].apply(c,arguments)},{dup:5}],13:[function(a,b,c){function d(a){if(f)switch(a.level){case g.log:f.log(a);break;case g.info:f.log(a);break;case g.warn:f.warn(a);break;case g.error:f.error(a)}}function e(a){return a}var f,g=a("./levels");"undefined"!=typeof console&&(f=console),/**
 * Returns a valid console interface with three methods:
 *
 * @returns {{write: function}}
 */
b.exports={write:d,pipe:e}},{"./levels":15}],14:[function(a,b,c){/**
 * @class
 * Logger instance with a name
 *
 * @param {string} name - Name of the logger
 */
function d(a,b){this.name=a,this._enabled=l(b,"enabled"),this._stream=l(b,"stream"),this._level=l(b,"level");var c=this;k[a]=this,/**
   * Create the logger method for each level. Set it up in the constructor
   * to properly lock in the context.
   */
Object.keys(j).forEach(function(a){c[a]=function(){return c.write(j[a],arguments)}})}/**
 * Function that create a JSON structure to be logged
 *
 * @param {string} name - Name of the logger
 * @param {int} level - Logging level. E.g. log, warn, error
 * @param {object} data - application data to be logged
 *
 * @returns {{date: Date, level: int, name: string, data: object}}
 *  Meta data to be logged
 */
function e(a,b,c){return{date:f(),level:b,name:a,data:c}}/**
 * Helper method to get timestamps for logged message
 *
 * @private
 */
function f(){return(new Date).getTime()}function g(a){return function(b,c){return b&&b.hasOwnProperty(c)?b[c]:a[c]}}var h,i=a("./consoleStream"),j=a("./levels"),k={},l=g({enabled:!0});/**
 * Expose levels to allow the customization of the values if need be.
 * Don't expect this to be a common use case.
 */
d.prototype.levels=j,/**
 * Helper factory method to create named loggers
 *
 * @returns {Logger} New logger instance
 */
d.prototype.create=function(a,b){return k[a]?k[a]:new d(a,b)},/**
 * Method to find a logger instance by name.
 *
 * @param {string} name - Name of the logger to find
 *
 * @returns {Logger}
 */
d.prototype.find=function(a){return k[a]},/**
 * Method to replace the current stream with a new one.
 *
 * @param {Stream} stream - Stream to write data to
 *
 * @returns {Stream} stream passed in
 */
d.prototype.pipe=function(a){return a!==this._stream&&(this._stream=a),a},/**
 * Log a message with a custom `level`
 */
d.prototype.write=function(a,b){return a=a||j.info,this.isEnabled(a)&&(this._stream||m._stream).write(e(this.name,a,b)),this},/**
 * Checks if the logger can write messages.
 *
 * @returns {boolean}
 */
d.prototype.isEnabled=function(a){if(!m._enabled)return!1;var b=this._enabled,c=this._level?this._level<=a:m._level<=a,d=!h||h===this;return b&&c&&d},/**
 * Method to enable the logger intance. If loggers have been disabled
 * globally then this flag will not have an immediate effect, until
 * loggers are globally enabled.
 */
d.prototype.enable=function(){return this._enabled=!0,this},/**
 * Method to disable the logger instance. Like {@link Logger#enable},
 * this setting does not have an immediate effect if loggers are globally
 * disabled.
 */
d.prototype.disable=function(){return this._enabled=!1,this},/**
 * Method to make sure *only* this logger logs messages. If another logger
 * is set to only, then the request is silently ignored.
 */
d.prototype.only=function(){return h||(h=this),this},/**
 * Method to remove the logger from the `only` state to allow other loggers
 * set themselves as only.
 */
d.prototype.all=function(){return h=null,this},/**
 * Enables loggers globally.
 */
d.prototype.enableAll=function(){return m.enable()},/**
 * Disables loggers globally.
 */
d.prototype.disableAll=function(){return m.disable()},/**
 * Sets the logging level
 */
d.prototype.level=function(a){return this._level=a,this};/**
 * Default logger instance available
 */
var m=new d("global",{stream:i,level:j.info,enabled:!0});b.exports=d.prototype["default"]=m},{"./consoleStream":13,"./levels":15}],15:[function(a,b,c){b.exports={log:1,info:1,warn:2,error:3}},{}],16:[function(a,b,c){/**
 * Provides functioanlity for aggregating matching rules that can
 * then be compared against a criteria to determine if the criteria
 * is met. The matching rules can be customized beyond simple string
 * comparison. Please take a look at {@link matchers}
 *
 * @class
 *
 * @param {Object} [options={}] - Settings for the rule to be created
 */
function d(a){a=a||{},this._name=d.configureName(a.name),this._match=d.configureMatch(a.match)}var e=a("./matcher"),f=0;/**
 * Helper method to generate rule names.
 *
 * @returns {string} Name of the rule
 */
d.configureName=function(a){return a||"rule-"+f++},/**
 * Helper method to generate rules that can be executed to match criteria.
 *
 * @param {*} match - If match is a function, then we just call that function
 *  to do the comparison for us. Provide a function when looking to customize
 *  how criteria are matched to rules. If match is not a function, the rule
 *  matcher is used. The default rule matcher is generally sufficient. But if
 *  it is not, then provide a function.  Furthermore, match can be an array
 *  of matching rules.
 *
 * @returns {Array.<Rule>} array of configured rule matchers.
 */
d.configureMatch=function(a){return a=a||[],a=a instanceof Array?a:[a],a.map(function(a){return a&&a.constructor===Function?a:e(a)})},/**
 * Method that returns the name of the rule
 *
 * @returns {string} Name of the rule
 */
d.prototype.getName=function(){return this._name},d.prototype.getLength=function(){return this._match.length},/**
 * Method to add a match to the list of matching rules
 *
 * @param {*} match - Matching rules to add. Can any type.
 *
 * @returns {Rule} this instance.
 */
d.prototype.addMatcher=function(a){return this._match=this._match.concat(d.configureMatch(a)),this},/**
 * Method to match only *one* rule
 *
 * @param {string} criteria - Input to test against.
 *
 * @returns {boolean} True if any rule is matched, false otherwise
 */
d.prototype.match=d.prototype.matchAny=function(a){var b,c,e=this._match;for(b=0,c=e.length;c>b;b++)if(d.__match(e[b],a))return!0;return!1},/**
 * Method to test againt *all* rules
 *
 * @param {string} criteria - Input to test against
 *
 * @returns {boolean} True is *all* rules match, false otherwise
 */
d.prototype.matchAll=function(a){var b,c,e=this._match;for(b=0,c=e.length;c>b;b++)if(!d.__match(e[b],a))return!1;return!0},/**
 * Function that call the matcher with the criteria.
 *
 * @private
 * @returns {boolean}
 */
d.__match=function(a,b){try{return a(b)}catch(c){}return!1},d.matcher=e,b.exports=d},{"./matcher":17}],17:[function(a,b,c){/**
 * Default matching rule with strict comparison. Or if the match is a regex
 * then the comparison is done by calling the `test` method on the regex.
 *
 * @param {*} match - If the input is a regex, then matches will be done using
 *  the regex itself. Otherwise, the comparison is done with strict comparison.
 *
 * @returns {boolean}
 */
function d(a){return a instanceof RegExp?function(b){return a.test(b)}:function(b){return b===a}}/**
 * Matcher for file extensions.
 *
 * @param {string} match - extensions to match. You can provide a pipe delimeted
 *  string to specify multiple extensions.  E.g. "js|jsx" will match js and jsx
 *  file extensions.
 *
 * @returns {function} Predicate that takes the criteria to match and returns
 *  true or false.
 */
d.extension=function(a){if(""===a||"string"!=typeof a)throw new TypeError("Matching rule must be a string");return a=new RegExp("\\.("+a+")$"),function(b){return a.test(b)}},/**
 * Matcher for strings. Use this to do strict comparison on strings.
 *
 * @param {string} match - String to match a criteria against.
 *
 * @returns {function} Predicate that takes the criteria to match and returns
 *  true or false.
 */
d.string=function(a){if("string"!=typeof a)throw new TypeError("Match type must be a string");return function(b){return a===b}},/**
 * Matcher for regex. Use this to create regex that can be used for matching
 * criteria.
 *
 * @param {string|RegExp} match - The input can be a string, which is converted
 *  to a regex. The input can also be a regex. This matcher will make sure we
 *  are working with regex matching rules.
 *
 * @returns {function} Predicate that takes the criteria to match and returns
 *  true or false.
 */
d.regex=function(a){if(""!==a&&"string"==typeof a&&(a=new RegExp(a)),!(a instanceof RegExp))throw new TypeError("Match type must be a string or a regex");return function(b){return a.test(b)}},b.exports=d},{}],18:[function(a,b,c){/**
 * @class
 *
 * Facade for relevant interfaces to register and import modules
 */
function d(a){a=h.merge({},a),this.settings=a,this.plugins={};
// Services! Components that process modules.
var b={resolve:new j(this),fetch:new k(this),transform:new l(this),dependency:new m(this),compile:new n(this),link:new i(this)};this.services=b;
// Register any default user provided providers that the services use.
// These guys run after plugins run.
for(provider in a)this.services.hasOwnProperty(provider)&&this.services[provider].provider(a[provider]);
// Controllers!  These guys make use of the services to build pipelines
// that build modules. Controllers use services, but services only use
// services, not controllers.
var c={resolver:new o(this),fetcher:new p(this),loader:new r(this),importer:new q(this),registry:new s(this),builder:new t(this)};this.controllers=c,
// Three methods as defined by:
// https://whatwg.github.io/loader/#sec-properties-of-the-loader-prototype-object
this["import"]=c.importer["import"].bind(c.importer),this.resolve=c.resolver.resolve.bind(c.resolver),this.load=c.loader.load.bind(c.loader),this.fetch=c.fetcher.fetch.bind(c.fetcher),this.important=c.importer.important.bind(c.importer),this.register=c.registry.register.bind(c.registry);
// Register plugins
for(var d in a.plugins)this.plugin(a.plugins[d]);
// Make this option a bit obtuse - I wanna make it a lil difficult for people to
// enable processing of node_modules since it can be rather difficult to tweak
// configurations to properly excluce modules to be processed.
a.doNotIgnoreNodeModules!==!0&&this.services.transform.ignore("path",/node_modules\//)}var e=a("loggero").disable(),f=a("dis-isa"),g=a("roolio"),h=a("belty"),i=a("./services/link"),j=a("./services/resolve"),k=a("./services/fetch"),l=a("./services/transform"),m=a("./services/dependency"),n=a("./services/compile"),o=a("./controllers/resolver"),p=a("./controllers/fetcher"),q=a("./controllers/importer"),r=a("./controllers/loader"),s=a("./controllers/registry"),t=a("./controllers/builder"),u=a("./module"),v=a("./plugin"),w=0;/**
 * Method to asynchronously load modules
 *
 * @param {string|Array.<string>} names - Module or list of modules names to
 *  load. These names map back to the paths settings Bitloader was created
 *  with.
 *
 * @returns {Promise} That when resolved, all the imported modules are passed
 *  back as arguments.
 */
d.prototype["import"]=function(){},/**
 * Method that converts a module name to a module path that can be used for
 * loading a module from storage.
 */
d.prototype.resolve=function(){},/**
 * Method for asynchronously loading modules.
 *
 * @returns {Pormise} That when resolved, it returns the full instance of the
 *  module loaded
 */
d.prototype.load=function(){},/**
 * Method to define a module to be asynchronously loaded via the
 * [import]{@link Bitloader#import} method
 *
 * @param {string} name - Name of the module to register
 * @param {Array.<string>} deps - Collection of dependencies to be loaded and
 *  passed into the factory callback method.
 * @param {Function} factory - Function to be called in order to instantiate
 *  (realize) the module
 */
d.prototype.register=function(){},/**
 * Method to get the source of a module.
 *
 * @param {string | Array.<string>} names - Name(s) of the modules to load.
 * @referrer {{path: string, name: string}} referrer - Module requesting
 *  the source.  Essential for processing relative paths.
 *
 * @returns {Promise} When resolved, the source(s) are returned
 */
d.prototype.getSource=function(a,b){var c=this;return this.controllers.fetcher.fetch(a,b).then(function(b){return f.isString(a)?c.getModule(b.id).source:b.map(function(a){return c.getModule(a.id).source})})},/**
 * Helper method to push source string through the transformation pipeline
 *
 * @param {string} source - Source code to transform.
 * @returns {Promise} When resolved, the transformed source is returned.
 */
d.prototype.transform=function(a){return this.services.transform.run(new u.Meta({name:"@transform",source:a})).then(function(a){return a.source})},/**
 * Clears the registry, which means that all cached modules and other pertinent
 * data will be deleted.
 */
d.prototype.clear=function(){return this.controllers.registry.clear(),this},/**
 * Checks if the module instance is in the module registry
 */
d.prototype.hasModule=function(a){return this.controllers.registry.hasModule(a)},/**
 * Returns the module instance if one exists.  If the module instance isn't in the
 * module registry, then a TypeError exception is thrown
 */
d.prototype.getModule=function(a){return this.controllers.registry.getModule(a)},/**
 * Interface to delete a module from the registry.
 *
 * @param {string} id - Id of the module to delete
 *
 * @returns {Module} Deleted module
 */
d.prototype.deleteModule=function(a){if(!(a instanceof u))throw new TypeError("Input is not an instance of Module");if(!this.controllers.registry.hasModule(a.id))throw new TypeError("Module instance `"+a.name+"` does not exists");return this.controllers.registry.deleteModule(a.id)},/**
 * Returns the module exports from the module registry. If the module exports has not
 * yet been fully compiled, then we defer to the loader to build the module and return
 * the exports.
 *
 * @param {string} id - The id of the module exports to get from the module registry
 *
 * @return {object} The module exports.
 */
d.prototype.getModuleExports=function(a){return this.getModule(a).exports},/**
 * Sets module evaluated exports directly in the module registry.
 *
 * @param {string} name - The name of the module, which is used by other modules
 *  that need it as a dependency.
 * @param {object} exports - The evaluated exports to be set
 *
 * @returns {object} The module instance with the exports information.
 */
d.prototype.setModuleExports=function(a,b){var c=new u({name:a,exports:b});return this.controllers.registry.setModule(u.State.READY,c)},/**
 * Add ignore rules for configuring what the different pipelines shoud not process.
 *
 * @param {Object} rule - Rule configuration
 * @returns {Bitloader} Bitloader instance
 */
d.prototype.ignore=function(a){if(!a)throw new TypeError("Must provide a rule configuration");var b,c,d;for((f.isArray(a)||f.isString(a))&&(a={match:a}),d=a.pipelines?"*"===a.pipelines?Object.keys(this.pipelines):f.isArray(a.pipelines)?a.pipelines:[a.pipelines]:["transform","dependency"],b=0,c=d.length;c>b;b++)this.services[d[b]].ignore("name",a.match);return this},/**
 * Registers plugins into the pipeline.
 *
 * @param {object} settings - Object whose keys are the name of the particular
 *  pipeline they intend to register with. For example, if the plugin is to
 *  register a `transform` and a `dependency` pipeline handler, then the
 *  plugin object will have entries with those names. E.g.
 *
 *  ``` javascript
 *  var pluginDefinition = {
 *    "transform": function(meta) {
 *      console.log(meta);
 *    },
 *    "dependency": function(meta) {
 *      console.log(meta);
 *    }
 *  };
 *
 *  bitlaoder.plugin(plugin);
 *  ```
 */
d.prototype.plugin=function(a,b){return f.isString(a)||(b=a,a=w++),this.plugins[a]||(this.plugins[a]=new v.Manager(this,this.services)),this.plugins[a].configure(b),this},
// Expose constructors and utilities
d.Module=u,d.Rule=g,d.logger=e,b.exports=d},{"./controllers/builder":19,"./controllers/fetcher":20,"./controllers/importer":22,"./controllers/loader":23,"./controllers/registry":24,"./controllers/resolver":25,"./module":27,"./plugin":29,"./services/compile":32,"./services/dependency":33,"./services/fetch":35,"./services/link":36,"./services/resolve":37,"./services/transform":38,belty:7,"dis-isa":12,loggero:14,roolio:16}],19:[function(a,b,c){function d(a){if(!a)throw new TypeError("Must provide a manager");this.manager=a,this.pipeline=new m([g(a),h(a)])}function e(a,b){return b.getDependencyExportsByName||(b=b.configure({getDependencyExportsByName:f(a,b)})),b=b.configure({source:b.source+i(b)}),a.pipeline.runSync(b)}function f(a,b){return function(c){return b.deps.filter(function(a){return a.name===c}).map(function(b){return a.build(b.id).exports})[0]}}function g(a){return k.serviceRunnerSync(a,l.State.LOADED,l.State.COMPILE,a.services.compile)}function h(a){return k.serviceRunnerSync(a,l.State.COMPILE,l.State.READY,a.services.link)}/**
 * Builds a `# sourceURL` string from the URL.
 *
 * @private
 *
 * @param {Module.Meta} moduleMeta - Module meta object this function is processing
 * @returns {string} The proper source url to be inserted in the module source
 */
function i(a){var b=j(a)?a.path:a.id;return b?"\n//# sourceURL="+b:""}/**
 * Verifies if a sourceUrl should be the full url of the module or just
 * the module name. This is to avoid having source maps and the source
 * url being added be the same url because browsers don't handle that
 * very well.
 *
 * @private
 *
 * @param {Module.Meta} moduleMeta - Module meta object this function is processing
 * @returns {boolean}
 */
function j(a){return a.source?-1===a.source.indexOf("//# sourceMappingURL=")&&-1===a.source.indexOf("//# sourceURL="):!1}
//var logger   = require("loggero").create("controllers/builder");
var k=a("./helpers"),l=a("../module"),m=a("../pipeline");d.prototype.build=function(a){return this.manager.controllers.registry.getModuleState(a)===l.State.READY?this.manager.controllers.registry.getModule(a):e(this,this.manager.controllers.registry.getModule(a))},b.exports=d},{"../module":27,"../pipeline":28,"./helpers":21}],20:[function(a,b,c){function d(a){if(!a)throw new TypeError("Must provide a manager");this.manager=a,this.inProgress={},this.pipeline=new o([f(a),g(a),h(a),i(this),m.setState(a,n.State.LOADED)])}function e(a,b,c){return a.manager.controllers.resolver.resolve(b,{name:c.name,path:c.path,id:c.id}).then(j(a))}function f(a){return m.serviceRunner(a,n.State.RESOLVE,n.State.FETCH,a.services.fetch)}function g(a){return m.serviceRunner(a,n.State.FETCH,n.State.TRANSFORM,a.services.transform)}function h(a){return m.serviceRunner(a,n.State.TRANSFORM,n.State.DEPENDENCY,a.services.dependency)}function i(a){return function(b){return Promise.all(b.deps.map(function(c){return a.fetch(c,b)})).then(function(a){return b.configure({deps:a})})}}function j(a){return function(b){return a.inProgress.hasOwnProperty(b.id)?a.inProgress[b.id].then(function(){return b}):a.manager.controllers.registry.hasModule(b.id)?Promise.resolve(b):(a.manager.controllers.registry.setModule(b,n.State.RESOLVE),k(a,b).then(function(){return b}))}}function k(a,b){function c(){delete a.inProgress[b.id]}var d=a.pipeline.run(b);return a.inProgress[b.id]=d,d.then(c,c),d}
//var logger   = require("loggero").create("controllers/fetch");
var l=a("dis-isa"),m=a("./helpers"),n=a("../module"),o=a("../pipeline");d.prototype.fetch=function(a,b){b=b||{};var c=this;return l.isString(a)?e(c,a,b):Promise.all(a.map(function(a){return e(c,a,b)}))},b.exports=d},{"../module":27,"../pipeline":28,"./helpers":21,"dis-isa":12}],21:[function(a,b,c){function d(a,b,c){return a.controllers.registry.hasModule(b)&&a.controllers.registry.getModuleState(b)===c}function e(a,b){return function(c){return a.controllers.registry.hasModule(c.id)&&a.controllers.registry.setModule(c,b),c}}function f(a,b,c,f,g){return g&&d(a,g.id,b)?f.run(e(a,c)(g)):Promise.resolve(g)}function g(a,b,c,f,g){return g&&d(a,g.id,b)?f.runSync(e(a,c)(g)):g}function h(a,b,c,d){return function(e){return f(a,b,c,d,e)}}function i(a,b,c,d){return function(e){return g(a,b,c,d,e)}}b.exports={ensureRegisteredState:d,serviceRunner:h,serviceRunnerSync:i,runService:f,runServiceSync:g,setState:e}},{}],22:[function(a,b,c){/**
 * Module importer. Primary function is to load Module instances and resolving
 * their dependencies in order to make the Module fully consumable.
 */
function d(a){if(!a)throw new TypeError("Must provide a manager");this._important=[],this.manager=a}function e(a){return function(){a._important=[]}}function f(a,b,c){return function(){return"string"==typeof b?Promise.resolve(b).then(g(a,c)):Promise.all(b.map(g(a,c)))}}function g(a,b){return function(c){return a._getModule(c,b)}}var h=a("loggero").create("controllers/importer");/**
 * Import is the method to load a Module
 *
 * @param {Array<string> | string} names - module(s) to import
 *
 * @returns {Promise}
 */
d.prototype["import"]=function(a,b){return Promise.resolve(this._important).then(e(this)).then(f(this,a,b))},/**
 * Imports that must occur before any other imports. So every import
 * will wait for all `important` imports to finish first.
 */
d.prototype.important=function(a,b){var c=f(this,a,b)();return this._important.push(c),c},/**
 * Gets the module by name.  If the module has not been loaded before, then
 * it is loaded via the module loader
 *
 * @param {Array<string>} names - Array of module names
 * @param {Object} options
 */
d.prototype._getModule=function(a,b){b=b||{};var c=this.manager;
// Wrap in a separate promise to handle this:
// https://github.com/MiguelCastillo/spromise/issues/35
return new Promise(function(b,d){function e(a){h.error(a),d(a)}function f(a){b(c.controllers.registry.getModule(a.id).exports)}c.controllers.loader.load(a).then(f,e)})},b.exports=d},{loggero:14}],23:[function(a,b,c){/**
 * The purpose of Loader is to return full instances of Module. Overview of the workflow:
 *
 * 1. Resolve - converts name to path for loading the module from storage.
 * 2. Fetch - load source from storage (remote server, local file system).
 * 3. Transform - transpile the source that was fetched.
 * 4. Dependency - parses out dependencies on other modules.
 * 5. Compile - evaluates the source that was fetched and transformed.
 * 6. Link - processes the entire dependency graph in order to instantiate modules.
 */
function d(a){if(!a)throw new TypeError("Must provide a manager");this.manager=a}function e(a,b){return function(c){return c?f(a,c,b).then(g(a)):Promise.reject("Must provide the name of the module to load")}}function f(a,b,c){return a.manager.controllers.fetcher.fetch(b,c)}function g(a){return function(b){return a.manager.controllers.builder.build(b.id)}}
//var logger = require("loggero").create("controllers/loader");
var h=a("dis-isa");/**
 * Handles the process of returning the instance of the Module if one exists, otherwise
 * the workflow for creating the instance is kicked off, which will eventually lead to
 * the creation of a Module instance
 *
 * @param {string} name - The name of the module to load.
 * @param {{path: string, name: string}} referrer - Object with the
 *  location and name of the requesting module.
 *
 * @returns {Promise} - Promise that will resolve to a Module instance
 */
d.prototype.load=function(a,b){return h.isString(a)?e(this,b)(a):Promise.all(a.map(e(this,b)))},b.exports=d},{"dis-isa":12}],24:[function(a,b,c){
//
// TODO: Make the registry stateless.
// I prefer controllers being stateless. But keeping the instance of the repository will do for now.
//
function d(a){if(!a)throw new Error("Manager must be provided");this.manager=a,this.repository=new g}function e(a){var b;do b=h++;while(a.repository.hasItem(b));return b}
//var logger = require("loggero").create("controllers/registry");
var f=a("../module"),g=a("../repository"),h=0;d.prototype.register=function(a,b,c,d){return this.setModule(new f.Meta({id:e(this),name:a,deps:b,factory:c,referrer:d}),f.State.REGISTERED)},d.prototype.hasModule=function(a){return this.repository.hasItem(a)},d.prototype.getModule=function(a){if(!this.hasModule(a))throw new Error("Module with id `"+a+"` not found");return this.repository.getItem(a).mod},d.prototype.setModule=function(a,b){var c=a.id;if(this.hasModule(c)&&this.getModuleState(c)===b)throw new Error("Module instance `"+a.name||a.id+"` already exists");return this.repository.setItem(c,{mod:a,state:b}),a},d.prototype.deleteModule=function(a){if(!this.hasModule(a))throw new Error("Unable to delete module with id `"+a+"`. Module not found.");return this.repository.deleteItem(a).mod},d.prototype.getModuleState=function(a){if(!this.hasModule(a))throw new Error("Module instance `"+a+"` not found");return this.repository.getItem(a).state},b.exports=d},{"../module":27,"../repository":30}],25:[function(a,b,c){function d(a){if(!a)throw new TypeError("Must provide a manager");this.manager=a}function e(a){var b={};return!a.path&&a.url&&(b.path=a.url&&a.url.href),!a.hasOwnProperty("id")&&a.path&&(b.id=a.path),a.configure(b)}
//var logger = require("loggero").create("controllers/resolver");
var f=a("../module");d.prototype.resolve=function(a,b){var c=new f.Meta({name:a,referrer:b});return this.manager.services.resolve.run(c).then(e)},b.exports=d},{"../module":27}],26:[function(a,b,c){function d(){this._matches=null,this._ignore=null}/**
 * Checks if the handler can process the input data based on whether
 * or not there are matches to be processed and if any of the matches
 * do match.
 */
function e(a,b){return!a||Object.keys(a).some(function(c){return a[c].match(b[c])})}var f=a("roolio");d.prototype.configure=function(a){var b;for(b in a.match)a.match.hasOwnProperty(b)&&this.match(b,a.match[b]);for(b in a.ignore)a.ignore.hasOwnProperty(b)&&this.ignore(b,a.ignore[b]);return this},/**
 * Method for adding matching rules used for determining whether or
 * not data should be processed by the handler.
 *
 * @prop {string} - Name of the property to test for matches.
 * @matches {array<string>|srting} - Matching rule pattern
 *
 * @returns {Plugin}
 */
d.prototype.match=function(a,b){return this._matches||(this._matches={}),this._matches[a]||(this._matches[a]=new f),this._matches[a].addMatcher(b),this},/**
 * Add ignore rules to prevent certain data from being processed
 * by the handler.
 */
d.prototype.ignore=function(a,b){return this._ignore||(this._ignore={}),this._ignore[a]||(this._ignore[a]=new f),this._ignore[a].addMatcher(b),this},d.prototype.runIgnore=function(a){return this._ignore&&e(this._ignore,a)},d.prototype.runMatch=function(a){return e(this._matches,a)},d.prototype.canExecute=function(a){return this.runIgnore(a)?!1:this.runMatch(a)},b.exports=d},{roolio:16}],27:[function(a,b,c){function d(a){if(!a)throw new TypeError("Must provide options to create the module");a.hasOwnProperty("exports")&&(this.exports=a.exports),a.hasOwnProperty("factory")&&(this.factory=a.factory),this.type=a.type||i.UNKNOWN,this.id=a.id||a.name,this.name=a.name,this.deps=a.deps?a.deps.slice(0):[]}/**
 * Module meta object
 */
function e(a){if(a=a||{},h.isString(a)&&(a={name:a}),!h.isString(a.name))throw new TypeError("Must provide a name, which is used by the resolver to resolve the path for the resource");this.deps=[],f(this,a)}/**
 * Merges in options into the module meta object
 */
function f(a,b){var c=g.extend(a,b);return b&&b.deps&&(c.deps=b.deps.slice(0)),c}var g=a("belty"),h=a("dis-isa"),i={UNKNOWN:"UNKNOWN",AMD:"AMD",//Asynchronous Module Definition
CJS:"CJS",//CommonJS
IIFE:"IIFE"},j={REGISTERED:"registered",RESOLVE:"resolve",FETCH:"fetch",TRANSFORM:"transform",DEPENDENCY:"dependency",LOADED:"loaded",COMPILE:"compile",LINK:"link",READY:"ready"};e.prototype.configure=function(a){
// Provide immutability to prevent side effects
return f(new e(this),a)},/**
 * Verifies that the module meta object is either already compiled or can be compiled.
 *
 * @returns {boolean}
 */
e.validate=function(a){if(!a)throw new TypeError("Must provide options");if(!e.isCompiled(a)&&!e.canCompile(a))throw new TypeError("ModuleMeta must provide a `source` string or `exports`.")},/**
 * Verifies is the module meta object has dependencies.
 *
 * @returns {boolean}
 */
e.hasDependencies=function(a){return a.deps.length},/**
 * A module meta object is considered compiled if it has a `exports` or `factory` method.
 * That's because those are the two things that the compile step actually generates
 * before creating a Module instance.
 *
 * @returns {boolean}
 */
e.isCompiled=function(a){return a.hasOwnProperty("exports")||h.isFunction(a.factory)},/**
 * Checks if the module meta object can be compiled by verifying that it has NOT
 * already been compiled and that it has a `source` property that need to be compiled.
 *
 * @returns {boolean}
 */
e.canCompile=function(a){return!e.isCompiled(a)&&h.isString(a.source)},d.Meta=e,d.Type=i,d.State=j,b.exports=d},{belty:7,"dis-isa":12}],28:[function(a,b,c){
//var logger = require("loggero").create("pipeline");
function d(a){this._handlers=a||[]}d.create=function(a){return new d(a)},d.prototype.use=function(a){return this._handlers.push(a),this},d.prototype.run=d.prototype.runAsync=function(a){return this.getRunnables().reduce(function(a,b){return a.then(b)},Promise.resolve(a))},d.prototype.runSync=function(a){return this.getRunnables().reduce(function(a,b){return b(a)},a)},d.prototype.getRunnables=function(){function a(){b=!0}var b=!1;return this._handlers.map(function(c){return function(d){return b?d:c.run?c.run.call(c,d,a):c.call(void 0,d,a)}})},b.exports=d},{}],29:[function(a,b,c){/**
 * Plugin class definition
 */
function d(a){r.call(this),this.handler=a,p.isString(a)&&this.ignore("name",a)}function e(a,b){this.loader=b,this.name=a,this.handlers=[]}/**
 * Executes all plugins to process the data. This handles plugin
 * handlers that return promises and it also provides a system to cancel
 * the promise sequence.
 */
function f(a,b,c){function d(){e=!0}var e=!1;return b.filter(function(b){return b.canExecute(a)}).reduce(function(b,f){return e?b:b.then(g(c,f)).then(h(a,d)).then(i(a))},Promise.resolve())}/**
 * Method to load a handler.
 */
function g(a,b){return function(){return p.isString(b.handler)?a["import"](b.handler).then(function(a){return p.isFunction(a)&&(a={handler:a}),b.configure(a)}):Promise.resolve(b)}}/**
 * Method that return a function that executes a plugin handler.
 */
function h(a,b){return function(c){return c.run(a,b)}}/**
 * Method the returns a function to process the result from a plugin
 */
function i(a){return function(b){return a.configure(b)}}/**
 * Plugin Manager is a plugin container that facilitates the execution of
 * plugins.
 */
function j(a,b){this._loader=a,this._services=b,this._plugins={},this._registrations={}}function k(a){return"match"!==a&&"ignore"!==a}function l(a){return function(b){return a._plugins[b]||(a._plugins[b]=new e(b,a._loader)),a._plugins[b]}}function m(a){return function(b){return b.configure(a[b.name])}}function n(a){return function(b){return!a._registrations[b.name]}}function o(a){return function(b){function c(c){return a.canExecute(c)?b.run(c):c}return a._registrations[b.name]=c,a._services[b.name].use(c),c}}
//var logger  = require("loggero").create("plugin");
var p=a("dis-isa"),q=a("belty"),r=a("./matches");d.prototype=Object.create(r.prototype),d.prototype.constructor=d,/**
 * Factory method to create Plugins
 *
 * @handler {string|function} - Plugin handler. Can be a module name to be lodaded,
 *  or a function.
 * @options {object} - Options.
 *
 * @returns {Handler} New Handler instance
 */
d.create=function(a,b){return a=new d(a),b?a.configure(b):a},/**
 * Configures handler with the provided options.
 */
d.prototype.configure=function(a){return r.prototype.configure.call(this,a),a.hasOwnProperty("handler")&&(this.handler=a.handler),a.hasOwnProperty("name")&&(this.name=a.name),this.options=q.merge({},this.options,a),this},d.prototype.run=function(a,b){return this.canExecute(a)?this.handler(a,this.options,b):Promise.resolve(a)},e.prototype.configure=function(a){return p.isArray(a)||(a=[a]),a.map(function(a){return(p.isFunction(a)||p.isString(a))&&(a={handler:a}),a}).map(function(a){return d.create(a.handler,a)}).reduce(function(a,b){return a.handlers.push(b),a},this),this},e.prototype.run=function(a){
//  if (!this.canExecute(data)) {
//    return Promise.resolve(data);
//  }
return f(a,this.handlers,this.loader)},j.prototype=Object.create(r.prototype),j.prototype.constructor=j,/**
 * Configure plugin. This is a way to setup matching rules and handlers
 * in a single convenient call.
 *
 * @returns {Plugin}
 */
j.prototype.configure=function(a){
// Process match/ignore options.
return r.prototype.configure.call(this,a),Object.keys(a).filter(k).map(l(this)).map(m(a)).filter(n(this)).map(o(this)),this},e.Manager=j,e.Handler=d,b.exports=e},{"./matches":26,belty:7,"dis-isa":12}],30:[function(a,b,c){/**
 * Generic repository for data.  Data must be stored with a state.
 */
function d(a){a=a||{},this.items=a.items||{}}d.prototype.clear=function(){return delete this.items,this.items={},this},d.prototype.hasItem=function(a){return this.items.hasOwnProperty(a)},d.prototype.getItem=function(a){if(!this.hasItem(a))throw new Error("`"+a+"` not found");return this.items[a]},d.prototype.deleteItem=function(a){if(!this.hasItem(a))throw new Error("Item with `"+a+"` cannot be deleted. Item not found");var b=this.items[a];return delete this.items[a],b},d.prototype.setItem=function(a,b){return this.items[a]=b},d.prototype.findItem=function(a){if(this.hasItem(a))return this.getItem(a);
//
// TODO: Add logic to match properties to find items with a particular shape.
//
throw new Error("Item not found")},b.exports=d},{}],31:[function(a,b,c){function d(){this._pipeline=new k}function e(a){return function(b){return a._provider&&a.canProcess(b)?a._provider(b):b}}function f(a){return function(b){return a._pipeline.runAsync(b)}}function g(a){return function(b){return a._pipeline.runSync(b)}}function h(a,b){return function(c){return Promise.resolve(b(c)).then(function(b){return a.processResult(c,b)})}}function i(a,b){return function(c){return a.processResult(c,b(c))}}var j=a("./matches"),k=a("./pipeline");d.prototype=Object.create(j.prototype),d.prototype.constructor=d,d.prototype.provider=function(a){return this._provider=a,this},d.prototype.use=function(a){return this._pipeline.use(a),this},d.prototype.canProcess=function(a){return this.canExecute(a)},d.prototype.run=d.prototype.runAsync=function(a){return this._logger&&this._logger.log(a.name,a),this.canProcess(a)?Promise.resolve(a).then(h(this,f(this))).then(h(this,e(this))):Promise.resolve(a)},d.prototype.runSync=function(a){return this._logger&&this._logger.log(a.name,a),this.canProcess(a)?[i(this,g(this)),i(this,e(this))].reduce(function(a,b){return b(a)},a):a},d.prototype.processResult=function(a,b){return b&&a!==b?a.configure(b):a},b.exports=d},{"./matches":26,"./pipeline":28}],32:[function(a,b,c){function d(a){g.call(this),this._manager=a,this._logger=e}var e=a("loggero").create("service/compile"),f=a("../module"),g=a("../service"),h=a("./eval");d.prototype=Object.create(g.prototype),d.prototype.constructor=d,d.prototype.canProcess=function(a){return this.canExecute(a)&&f.Meta.canCompile(a)},d.prototype.runSync=function(a){if(this._logger&&this._logger.log(a.name,a),!this.canProcess(a))return a;var b={exports:{}};return h(this._manager.controllers.loader,b,b.exports,a.getDependencyExportsByName,a.directory,a.path,a.source),a.configure(b)},b.exports=d},{"../module":27,"../service":31,"./eval":34,loggero:14}],33:[function(a,b,c){function d(a){g.call(this),this._manager=a,this._logger=e}var e=a("loggero").create("service/dependency"),f=a("dis-isa"),g=a("../service");d.prototype=Object.create(g.prototype),d.prototype.constructor=d,d.prototype.canProcess=function(a){return this.canExecute(a)&&f.isString(a.source)},b.exports=d},{"../service":31,"dis-isa":12,loggero:14}],34:[function(require,module,exports){/*eslint no-unused-vars: 0*/
module.exports=function(loader,module,exports,require,__dirname,__filename){eval(arguments[arguments.length-1])}},{}],35:[function(a,b,c){function d(a){f.call(this),this._manager=a,this._logger=e}var e=a("loggero").create("service/fetch"),f=a("../service");d.prototype=Object.create(f.prototype),d.prototype.constructor=d,d.prototype.canProcess=function(a){return this.canExecute(a)&&a.hasOwnProperty("path")&&!a.hasOwnProperty("code")&&!a.hasOwnProperty("source")&&!a.hasOwnProperty("factory")},b.exports=d},{"../service":31,loggero:14}],36:[function(a,b,c){function d(a){g.call(this),this._manager=a}var e=a("loggero").create("service/linker"),f=a("../module"),g=a("../service");d.prototype=Object.create(g.prototype),d.prototype.constructor=d,d.prototype.canProcess=function(a){return this.canExecute(a)&&f.Meta.isCompiled(a)},/**
 * The linker step is where we take the evaluated source, build all the dependencies
 * and call the factory method on the module if available.
 *
 * This is the step where the Module instance is finally created.
 *
 * @returns {Module}
 */
d.prototype.runSync=function(a){function b(a){e.log(a.name,a);
// Build all the dependecies in the dependency graph.
var d=a.deps.map(function(a){return c.controllers.registry.getModuleState(a.id)===f.State.READY?c.controllers.registry.getModule(a.id).exports:b(c.controllers.builder.build(a.id)).exports});
// If the module itself is not yet built, then build it if there is a factory
// method that can be called.
return a.factory&&!a.hasOwnProperty("exports")&&(a.exports=a.factory.apply(void 0,d)),a}if(this._logger&&this._logger.log(a.name,a),!this.canProcess(a))throw new TypeError("Module "+a.name+" cannot be linked");var c=this._manager,d=new f(a);
// Link it
// We will coerce the name no matter what name (if one at all) the Module was
// created with. This will ensure a consistent state in the loading engine.
// Set the mod.meta for convenience
return d.name=a.name,d.meta=a,b(d)},b.exports=d},{"../module":27,"../service":31,loggero:14}],37:[function(a,b,c){function d(a){f.call(this),this._manager=a,this._logger=e}var e=a("loggero").create("service/resolve"),f=a("../service");d.prototype=Object.create(f.prototype),d.prototype.constructor=d,d.prototype.canProcess=function(a){return this.canExecute(a)&&!a.hasOwnProperty("path")},b.exports=d},{"../service":31,loggero:14}],38:[function(a,b,c){function d(a){g.call(this),this._manager=a,this._logger=e}var e=a("loggero").create("service/transform"),f=a("dis-isa"),g=a("../service");d.prototype=Object.create(g.prototype),d.prototype.constructor=d,d.prototype.canProcess=function(a){return this.canExecute(a)&&f.isString(a.source)},b.exports=d},{"../service":31,"dis-isa":12,loggero:14}],39:[function(a,b,c){(function(d){!function(a){if("object"==typeof c&&"undefined"!=typeof b)b.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof d?d:"undefined"!=typeof self?self:this,e.acorn=a()}}(function(){return function b(c,d,e){function f(h,i){if(!d[h]){if(!c[h]){var j="function"==typeof a&&a;if(!i&&j)return j(h,!0);if(g)return g(h,!0);var k=new Error("Cannot find module '"+h+"'");throw k.code="MODULE_NOT_FOUND",k}var l=d[h]={exports:{}};c[h][0].call(l.exports,function(a){var b=c[h][1][a];return f(b?b:a)},l,l.exports,b,c,d,e)}return d[h].exports}for(var g="function"==typeof a&&a,h=0;h<e.length;h++)f(e[h]);return f}({1:[function(a,b,c){
// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
"use strict";var d=a("./tokentype"),e=a("./state"),f=e.Parser.prototype;
// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.
f.checkPropClash=function(a,b){if(!(this.options.ecmaVersion>=6&&(a.computed||a.method||a.shorthand))){var c=a.key,d=void 0;switch(c.type){case"Identifier":d=c.name;break;case"Literal":d=String(c.value);break;default:return}var e=a.kind;if(this.options.ecmaVersion>=6)return void("__proto__"===d&&"init"===e&&(b.proto&&this.raise(c.start,"Redefinition of __proto__ property"),b.proto=!0));d="$"+d;var f=b[d];if(f){var g="init"!==e;((this.strict||g)&&f[e]||!(g^f.init))&&this.raise(c.start,"Redefinition of property")}else f=b[d]={init:!1,get:!1,set:!1};f[e]=!0}},
// ### Expression parsing
// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).
f.parseExpression=function(a,b){var c=this.start,e=this.startLoc,f=this.parseMaybeAssign(a,b);if(this.type===d.types.comma){var g=this.startNodeAt(c,e);for(g.expressions=[f];this.eat(d.types.comma);)g.expressions.push(this.parseMaybeAssign(a,b));return this.finishNode(g,"SequenceExpression")}return f},
// Parse an assignment expression. This includes applications of
// operators like `+=`.
f.parseMaybeAssign=function(a,b,c){if(this.type==d.types._yield&&this.inGenerator)return this.parseYield();var e=!1;b||(b={shorthandAssign:0,trailingComma:0},e=!0);var f=this.start,g=this.startLoc;(this.type==d.types.parenL||this.type==d.types.name)&&(this.potentialArrowAt=this.start);var h=this.parseMaybeConditional(a,b);if(c&&(h=c.call(this,h,f,g)),this.type.isAssign){e&&this.checkPatternErrors(b,!0);var i=this.startNodeAt(f,g);// reset because shorthand default was used correctly
return i.operator=this.value,i.left=this.type===d.types.eq?this.toAssignable(h):h,b.shorthandAssign=0,this.checkLVal(h),this.next(),i.right=this.parseMaybeAssign(a),this.finishNode(i,"AssignmentExpression")}return e&&this.checkExpressionErrors(b,!0),h},
// Parse a ternary conditional (`?:`) operator.
f.parseMaybeConditional=function(a,b){var c=this.start,e=this.startLoc,f=this.parseExprOps(a,b);if(this.checkExpressionErrors(b))return f;if(this.eat(d.types.question)){var g=this.startNodeAt(c,e);return g.test=f,g.consequent=this.parseMaybeAssign(),this.expect(d.types.colon),g.alternate=this.parseMaybeAssign(a),this.finishNode(g,"ConditionalExpression")}return f},
// Start the precedence parser.
f.parseExprOps=function(a,b){var c=this.start,d=this.startLoc,e=this.parseMaybeUnary(b);return this.checkExpressionErrors(b)?e:this.parseExprOp(e,c,d,-1,a)},
// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
f.parseExprOp=function(a,b,c,e,f){var g=this.type.binop;if(null!=g&&(!f||this.type!==d.types._in)&&g>e){var h=this.startNodeAt(b,c);h.left=a,h.operator=this.value;var i=this.type;this.next();var j=this.start,k=this.startLoc;return h.right=this.parseExprOp(this.parseMaybeUnary(),j,k,g,f),this.finishNode(h,i===d.types.logicalOR||i===d.types.logicalAND?"LogicalExpression":"BinaryExpression"),this.parseExprOp(h,b,c,e,f)}return a},
// Parse unary operators, both prefix and postfix.
f.parseMaybeUnary=function(a){if(this.type.prefix){var b=this.startNode(),c=this.type===d.types.incDec;return b.operator=this.value,b.prefix=!0,this.next(),b.argument=this.parseMaybeUnary(),this.checkExpressionErrors(a,!0),c?this.checkLVal(b.argument):this.strict&&"delete"===b.operator&&"Identifier"===b.argument.type&&this.raise(b.start,"Deleting local variable in strict mode"),this.finishNode(b,c?"UpdateExpression":"UnaryExpression")}var e=this.start,f=this.startLoc,g=this.parseExprSubscripts(a);if(this.checkExpressionErrors(a))return g;for(;this.type.postfix&&!this.canInsertSemicolon();){var b=this.startNodeAt(e,f);b.operator=this.value,b.prefix=!1,b.argument=g,this.checkLVal(g),this.next(),g=this.finishNode(b,"UpdateExpression")}return g},
// Parse call, dot, and `[]`-subscript expressions.
f.parseExprSubscripts=function(a){var b=this.start,c=this.startLoc,d=this.parseExprAtom(a),e="ArrowFunctionExpression"===d.type&&")"!==this.input.slice(this.lastTokStart,this.lastTokEnd);return this.checkExpressionErrors(a)||e?d:this.parseSubscripts(d,b,c)},f.parseSubscripts=function(a,b,c,e){for(;;)if(this.eat(d.types.dot)){var f=this.startNodeAt(b,c);f.object=a,f.property=this.parseIdent(!0),f.computed=!1,a=this.finishNode(f,"MemberExpression")}else if(this.eat(d.types.bracketL)){var f=this.startNodeAt(b,c);f.object=a,f.property=this.parseExpression(),f.computed=!0,this.expect(d.types.bracketR),a=this.finishNode(f,"MemberExpression")}else if(!e&&this.eat(d.types.parenL)){var f=this.startNodeAt(b,c);f.callee=a,f.arguments=this.parseExprList(d.types.parenR,!1),a=this.finishNode(f,"CallExpression")}else{if(this.type!==d.types.backQuote)return a;var f=this.startNodeAt(b,c);f.tag=a,f.quasi=this.parseTemplate(),a=this.finishNode(f,"TaggedTemplateExpression")}},
// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
f.parseExprAtom=function(a){var b=void 0,c=this.potentialArrowAt==this.start;switch(this.type){case d.types._super:this.inFunction||this.raise(this.start,"'super' outside of function or class");case d.types._this:var e=this.type===d.types._this?"ThisExpression":"Super";return b=this.startNode(),this.next(),this.finishNode(b,e);case d.types._yield:this.inGenerator&&this.unexpected();case d.types.name:var f=this.start,g=this.startLoc,h=this.parseIdent(this.type!==d.types.name);return c&&!this.canInsertSemicolon()&&this.eat(d.types.arrow)?this.parseArrowExpression(this.startNodeAt(f,g),[h]):h;case d.types.regexp:var i=this.value;return b=this.parseLiteral(i.value),b.regex={pattern:i.pattern,flags:i.flags},b;case d.types.num:case d.types.string:return this.parseLiteral(this.value);case d.types._null:case d.types._true:case d.types._false:return b=this.startNode(),b.value=this.type===d.types._null?null:this.type===d.types._true,b.raw=this.type.keyword,this.next(),this.finishNode(b,"Literal");case d.types.parenL:return this.parseParenAndDistinguishExpression(c);case d.types.bracketL:
// check whether this is array comprehension or regular array
// check whether this is array comprehension or regular array
return b=this.startNode(),this.next(),this.options.ecmaVersion>=7&&this.type===d.types._for?this.parseComprehension(b,!1):(b.elements=this.parseExprList(d.types.bracketR,!0,!0,a),this.finishNode(b,"ArrayExpression"));case d.types.braceL:return this.parseObj(!1,a);case d.types._function:return b=this.startNode(),this.next(),this.parseFunction(b,!1);case d.types._class:return this.parseClass(this.startNode(),!1);case d.types._new:return this.parseNew();case d.types.backQuote:return this.parseTemplate();default:this.unexpected()}},f.parseLiteral=function(a){var b=this.startNode();return b.value=a,b.raw=this.input.slice(this.start,this.end),this.next(),this.finishNode(b,"Literal")},f.parseParenExpression=function(){this.expect(d.types.parenL);var a=this.parseExpression();return this.expect(d.types.parenR),a},f.parseParenAndDistinguishExpression=function(a){var b=this.start,c=this.startLoc,e=void 0;if(this.options.ecmaVersion>=6){if(this.next(),this.options.ecmaVersion>=7&&this.type===d.types._for)return this.parseComprehension(this.startNodeAt(b,c),!0);for(var f=this.start,g=this.startLoc,h=[],i=!0,j={shorthandAssign:0,trailingComma:0},k=void 0,l=void 0;this.type!==d.types.parenR;){if(i?i=!1:this.expect(d.types.comma),this.type===d.types.ellipsis){k=this.start,h.push(this.parseParenItem(this.parseRest()));break}this.type!==d.types.parenL||l||(l=this.start),h.push(this.parseMaybeAssign(!1,j,this.parseParenItem))}var m=this.start,n=this.startLoc;if(this.expect(d.types.parenR),a&&!this.canInsertSemicolon()&&this.eat(d.types.arrow))return this.checkPatternErrors(j,!0),l&&this.unexpected(l),this.parseParenArrowList(b,c,h);h.length||this.unexpected(this.lastTokStart),k&&this.unexpected(k),this.checkExpressionErrors(j,!0),h.length>1?(e=this.startNodeAt(f,g),e.expressions=h,this.finishNodeAt(e,"SequenceExpression",m,n)):e=h[0]}else e=this.parseParenExpression();if(this.options.preserveParens){var o=this.startNodeAt(b,c);return o.expression=e,this.finishNode(o,"ParenthesizedExpression")}return e},f.parseParenItem=function(a){return a},f.parseParenArrowList=function(a,b,c){return this.parseArrowExpression(this.startNodeAt(a,b),c)};
// New's precedence is slightly tricky. It must allow its argument
// to be a `[]` or dot subscript expression, but not a call — at
// least, not without wrapping it in parentheses. Thus, it uses the
var g=[];f.parseNew=function(){var a=this.startNode(),b=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(d.types.dot))return a.meta=b,a.property=this.parseIdent(!0),"target"!==a.property.name&&this.raise(a.property.start,"The only valid meta property for new is new.target"),this.inFunction||this.raise(a.start,"new.target can only be used in functions"),this.finishNode(a,"MetaProperty");var c=this.start,e=this.startLoc;return a.callee=this.parseSubscripts(this.parseExprAtom(),c,e,!0),this.eat(d.types.parenL)?a.arguments=this.parseExprList(d.types.parenR,!1):a.arguments=g,this.finishNode(a,"NewExpression")},
// Parse template expression.
f.parseTemplateElement=function(){var a=this.startNode();return a.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,"\n"),cooked:this.value},this.next(),a.tail=this.type===d.types.backQuote,this.finishNode(a,"TemplateElement")},f.parseTemplate=function(){var a=this.startNode();this.next(),a.expressions=[];var b=this.parseTemplateElement();for(a.quasis=[b];!b.tail;)this.expect(d.types.dollarBraceL),a.expressions.push(this.parseExpression()),this.expect(d.types.braceR),a.quasis.push(b=this.parseTemplateElement());return this.next(),this.finishNode(a,"TemplateLiteral")},
// Parse an object literal or binding pattern.
f.parseObj=function(a,b){var c=this.startNode(),e=!0,f={};for(c.properties=[],this.next();!this.eat(d.types.braceR);){if(e)e=!1;else if(this.expect(d.types.comma),this.afterTrailingComma(d.types.braceR))break;var g=this.startNode(),h=void 0,i=void 0,j=void 0;this.options.ecmaVersion>=6&&(g.method=!1,g.shorthand=!1,(a||b)&&(i=this.start,j=this.startLoc),a||(h=this.eat(d.types.star))),this.parsePropertyName(g),this.parsePropertyValue(g,a,h,i,j,b),this.checkPropClash(g,f),c.properties.push(this.finishNode(g,"Property"))}return this.finishNode(c,a?"ObjectPattern":"ObjectExpression")},f.parsePropertyValue=function(a,b,c,e,f,g){if(this.eat(d.types.colon))a.value=b?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,g),a.kind="init";else if(this.options.ecmaVersion>=6&&this.type===d.types.parenL)b&&this.unexpected(),a.kind="init",a.method=!0,a.value=this.parseMethod(c);else if(this.options.ecmaVersion>=5&&!a.computed&&"Identifier"===a.key.type&&("get"===a.key.name||"set"===a.key.name)&&this.type!=d.types.comma&&this.type!=d.types.braceR){(c||b)&&this.unexpected(),a.kind=a.key.name,this.parsePropertyName(a),a.value=this.parseMethod(!1);var h="get"===a.kind?0:1;if(a.value.params.length!==h){var i=a.value.start;"get"===a.kind?this.raise(i,"getter should have no params"):this.raise(i,"setter should have exactly one param")}}else this.options.ecmaVersion>=6&&!a.computed&&"Identifier"===a.key.type?(a.kind="init",b?((this.keywords.test(a.key.name)||(this.strict?this.reservedWordsStrictBind:this.reservedWords).test(a.key.name))&&this.raise(a.key.start,"Binding "+a.key.name),a.value=this.parseMaybeDefault(e,f,a.key)):this.type===d.types.eq&&g?(g.shorthandAssign||(g.shorthandAssign=this.start),a.value=this.parseMaybeDefault(e,f,a.key)):a.value=a.key,a.shorthand=!0):this.unexpected()},f.parsePropertyName=function(a){if(this.options.ecmaVersion>=6){if(this.eat(d.types.bracketL))return a.computed=!0,a.key=this.parseMaybeAssign(),this.expect(d.types.bracketR),a.key;a.computed=!1}return a.key=this.type===d.types.num||this.type===d.types.string?this.parseExprAtom():this.parseIdent(!0)},
// Initialize empty function node.
f.initFunction=function(a){a.id=null,this.options.ecmaVersion>=6&&(a.generator=!1,a.expression=!1)},
// Parse object or class method.
f.parseMethod=function(a){var b=this.startNode();return this.initFunction(b),this.expect(d.types.parenL),b.params=this.parseBindingList(d.types.parenR,!1,!1),this.options.ecmaVersion>=6&&(b.generator=a),this.parseFunctionBody(b,!1),this.finishNode(b,"FunctionExpression")},
// Parse arrow function expression with given parameters.
f.parseArrowExpression=function(a,b){return this.initFunction(a),a.params=this.toAssignableList(b,!0),this.parseFunctionBody(a,!0),this.finishNode(a,"ArrowFunctionExpression")},
// Parse function body and check parameters.
f.parseFunctionBody=function(a,b){var c=b&&this.type!==d.types.braceL;if(c)a.body=this.parseMaybeAssign(),a.expression=!0;else{
// Start a new scope with regard to labels and the `inFunction`
// flag (restore them to their old value afterwards).
var e=this.inFunction,f=this.inGenerator,g=this.labels;this.inFunction=!0,this.inGenerator=a.generator,this.labels=[],a.body=this.parseBlock(!0),a.expression=!1,this.inFunction=e,this.inGenerator=f,this.labels=g}
// If this is a strict mode function, verify that argument names
// are not repeated, and it does not try to bind the words `eval`
// or `arguments`.
if(this.strict||!c&&a.body.body.length&&this.isUseStrict(a.body.body[0])){var h=this.strict;this.strict=!0,a.id&&this.checkLVal(a.id,!0),this.checkParams(a),this.strict=h}else b&&this.checkParams(a)},
// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.
f.checkParams=function(a){for(var b={},c=0;c<a.params.length;c++)this.checkLVal(a.params[c],!0,b)},
// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).
f.parseExprList=function(a,b,c,e){for(var f=[],g=!0;!this.eat(a);){if(g)g=!1;else if(this.expect(d.types.comma),this.type===a&&e&&!e.trailingComma&&(e.trailingComma=this.lastTokStart),b&&this.afterTrailingComma(a))break;var h=void 0;h=c&&this.type===d.types.comma?null:this.type===d.types.ellipsis?this.parseSpread(e):this.parseMaybeAssign(!1,e),f.push(h)}return f},
// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.
f.parseIdent=function(a){var b=this.startNode();return a&&"never"==this.options.allowReserved&&(a=!1),this.type===d.types.name?(!a&&(this.strict?this.reservedWordsStrict:this.reservedWords).test(this.value)&&(this.options.ecmaVersion>=6||-1==this.input.slice(this.start,this.end).indexOf("\\"))&&this.raise(this.start,"The keyword '"+this.value+"' is reserved"),b.name=this.value):a&&this.type.keyword?b.name=this.type.keyword:this.unexpected(),this.next(),this.finishNode(b,"Identifier")},
// Parses yield expression inside generator.
f.parseYield=function(){var a=this.startNode();return this.next(),this.type==d.types.semi||this.canInsertSemicolon()||this.type!=d.types.star&&!this.type.startsExpr?(a.delegate=!1,a.argument=null):(a.delegate=this.eat(d.types.star),a.argument=this.parseMaybeAssign()),this.finishNode(a,"YieldExpression")},
// Parses array and generator comprehensions.
f.parseComprehension=function(a,b){for(a.blocks=[];this.type===d.types._for;){var c=this.startNode();this.next(),this.expect(d.types.parenL),c.left=this.parseBindingAtom(),this.checkLVal(c.left,!0),this.expectContextual("of"),c.right=this.parseExpression(),this.expect(d.types.parenR),a.blocks.push(this.finishNode(c,"ComprehensionBlock"))}return a.filter=this.eat(d.types._if)?this.parseParenExpression():null,a.body=this.parseExpression(),this.expect(b?d.types.parenR:d.types.bracketR),a.generator=b,this.finishNode(a,"ComprehensionExpression")}},{"./state":10,"./tokentype":14}],2:[function(a,b,c){
// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.
// Reserved word lists for various dialects of the language
"use strict";
// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function d(a,b){for(var c=65536,d=0;d<b.length;d+=2){if(c+=b[d],c>a)return!1;if(c+=b[d+1],c>=a)return!0}}
// Test whether a given character code starts an identifier.
function e(a,b){return 65>a?36===a:91>a?!0:97>a?95===a:123>a?!0:65535>=a?a>=170&&l.test(String.fromCharCode(a)):b===!1?!1:d(a,n)}
// Test whether a given character is part of an identifier.
function f(a,b){return 48>a?36===a:58>a?!0:65>a?!1:91>a?!0:97>a?95===a:123>a?!0:65535>=a?a>=170&&m.test(String.fromCharCode(a)):b===!1?!1:d(a,n)||d(a,o)}c.__esModule=!0,c.isIdentifierStart=e,c.isIdentifierChar=f;var g={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"};c.reservedWords=g;
// And the keywords
var h="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",i={5:h,6:h+" let const class extends export import yield super"};c.keywords=i;
// ## Character categories
// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var j="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",k="‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏ᦰ-ᧀᧈᧉ᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︭︳︴﹍-﹏０-９＿",l=new RegExp("["+j+"]"),m=new RegExp("["+j+k+"]");j=k=null;
// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by tools/generate-identifier-regex.js
var n=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,99,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,98,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,955,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,38,17,2,24,133,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,32,4,287,47,21,1,2,0,185,46,82,47,21,0,60,42,502,63,32,0,449,56,1288,920,104,110,2962,1070,13266,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,16481,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,1340,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,16355,541],o=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,16,9,83,11,168,11,6,9,8,2,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,316,19,13,9,214,6,3,8,112,16,16,9,82,12,9,9,535,9,20855,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,4305,6,792618,239]},{}],3:[function(a,b,c){
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/ternjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/ternjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js
"use strict";
// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
function d(a,b){return new g.Parser(b,a).parse()}
// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.
function e(a,b,c){var d=new g.Parser(c,a,b);return d.nextToken(),d.parseExpression()}
// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.
function f(a,b){return new g.Parser(b,a)}c.__esModule=!0,c.parse=d,c.parseExpressionAt=e,c.tokenizer=f;var g=a("./state");a("./parseutil"),a("./statement"),a("./lval"),a("./expression"),a("./location"),c.Parser=g.Parser,c.plugins=g.plugins;var h=a("./options");c.defaultOptions=h.defaultOptions;var i=a("./locutil");c.Position=i.Position,c.SourceLocation=i.SourceLocation,c.getLineInfo=i.getLineInfo;var j=a("./node");c.Node=j.Node;var k=a("./tokentype");c.TokenType=k.TokenType,c.tokTypes=k.types;var l=a("./tokencontext");c.TokContext=l.TokContext,c.tokContexts=l.types;var m=a("./identifier");c.isIdentifierChar=m.isIdentifierChar,c.isIdentifierStart=m.isIdentifierStart;var n=a("./tokenize");c.Token=n.Token;var o=a("./whitespace");c.isNewLine=o.isNewLine,c.lineBreak=o.lineBreak,c.lineBreakG=o.lineBreakG;var p="2.6.4";c.version=p},{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(a,b,c){"use strict";var d=a("./state"),e=a("./locutil"),f=d.Parser.prototype;
// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.
f.raise=function(a,b){var c=e.getLineInfo(this.input,a);b+=" ("+c.line+":"+c.column+")";var d=new SyntaxError(b);throw d.pos=a,d.loc=c,d.raisedAt=this.pos,d},f.curPosition=function(){return this.options.locations?new e.Position(this.curLine,this.pos-this.lineStart):void 0}},{"./locutil":5,"./state":10}],5:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a,b){for(var c=1,d=0;;){f.lineBreakG.lastIndex=d;var e=f.lineBreakG.exec(a);if(!(e&&e.index<b))return new g(c,b-d);++c,d=e.index+e[0].length}}c.__esModule=!0,c.getLineInfo=e;var f=a("./whitespace"),g=function(){function a(b,c){d(this,a),this.line=b,this.column=c}return a.prototype.offset=function(b){return new a(this.line,this.column+b)},a}();c.Position=g;var h=function i(a,b,c){d(this,i),this.start=b,this.end=c,null!==a.sourceFile&&(this.source=a.sourceFile)};c.SourceLocation=h},{"./whitespace":16}],6:[function(a,b,c){"use strict";var d=a("./tokentype"),e=a("./state"),f=a("./util"),g=e.Parser.prototype;
// Convert existing expression atom to assignable pattern
// if possible.
g.toAssignable=function(a,b){if(this.options.ecmaVersion>=6&&a)switch(a.type){case"Identifier":case"ObjectPattern":case"ArrayPattern":break;case"ObjectExpression":a.type="ObjectPattern";for(var c=0;c<a.properties.length;c++){var d=a.properties[c];"init"!==d.kind&&this.raise(d.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(d.value,b)}break;case"ArrayExpression":a.type="ArrayPattern",this.toAssignableList(a.elements,b);break;case"AssignmentExpression":if("="!==a.operator){this.raise(a.left.end,"Only '=' operator can be used for specifying default value.");break}a.type="AssignmentPattern",delete a.operator;case"AssignmentPattern":"YieldExpression"===a.right.type&&this.raise(a.right.start,"Yield expression cannot be a default value");break;case"ParenthesizedExpression":a.expression=this.toAssignable(a.expression,b);break;case"MemberExpression":if(!b)break;default:this.raise(a.start,"Assigning to rvalue")}return a},
// Convert list of expression atoms to binding list.
g.toAssignableList=function(a,b){var c=a.length;if(c){var d=a[c-1];if(d&&"RestElement"==d.type)--c;else if(d&&"SpreadElement"==d.type){d.type="RestElement";var e=d.argument;this.toAssignable(e,b),"Identifier"!==e.type&&"MemberExpression"!==e.type&&"ArrayPattern"!==e.type&&this.unexpected(e.start),--c}b&&"RestElement"===d.type&&"Identifier"!==d.argument.type&&this.unexpected(d.argument.start)}for(var f=0;c>f;f++){var g=a[f];g&&this.toAssignable(g,b)}return a},
// Parses spread element.
g.parseSpread=function(a){var b=this.startNode();return this.next(),b.argument=this.parseMaybeAssign(a),this.finishNode(b,"SpreadElement")},g.parseRest=function(a){var b=this.startNode();
// RestElement inside of a function parameter must be an identifier
return this.next(),a?b.argument=this.type===d.types.name?this.parseIdent():this.unexpected():b.argument=this.type===d.types.name||this.type===d.types.bracketL?this.parseBindingAtom():this.unexpected(),this.finishNode(b,"RestElement")},
// Parses lvalue (assignable) atom.
g.parseBindingAtom=function(){if(this.options.ecmaVersion<6)return this.parseIdent();switch(this.type){case d.types.name:return this.parseIdent();case d.types.bracketL:var a=this.startNode();return this.next(),a.elements=this.parseBindingList(d.types.bracketR,!0,!0),this.finishNode(a,"ArrayPattern");case d.types.braceL:return this.parseObj(!0);default:this.unexpected()}},g.parseBindingList=function(a,b,c,e){for(var f=[],g=!0;!this.eat(a);)if(g?g=!1:this.expect(d.types.comma),b&&this.type===d.types.comma)f.push(null);else{if(c&&this.afterTrailingComma(a))break;if(this.type===d.types.ellipsis){var h=this.parseRest(e);this.parseBindingListItem(h),f.push(h),this.expect(a);break}var i=this.parseMaybeDefault(this.start,this.startLoc);this.parseBindingListItem(i),f.push(i)}return f},g.parseBindingListItem=function(a){return a},
// Parses assignment pattern around given atom if possible.
g.parseMaybeDefault=function(a,b,c){if(c=c||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(d.types.eq))return c;var e=this.startNodeAt(a,b);return e.left=c,e.right=this.parseMaybeAssign(),this.finishNode(e,"AssignmentPattern")},
// Verify that a node is an lval — something that can be assigned
// to.
g.checkLVal=function(a,b,c){switch(a.type){case"Identifier":this.strict&&this.reservedWordsStrictBind.test(a.name)&&this.raise(a.start,(b?"Binding ":"Assigning to ")+a.name+" in strict mode"),c&&(f.has(c,a.name)&&this.raise(a.start,"Argument name clash"),c[a.name]=!0);break;case"MemberExpression":b&&this.raise(a.start,(b?"Binding":"Assigning to")+" member expression");break;case"ObjectPattern":for(var d=0;d<a.properties.length;d++)this.checkLVal(a.properties[d].value,b,c);break;case"ArrayPattern":for(var d=0;d<a.elements.length;d++){var e=a.elements[d];e&&this.checkLVal(e,b,c)}break;case"AssignmentPattern":this.checkLVal(a.left,b,c);break;case"RestElement":this.checkLVal(a.argument,b,c);break;case"ParenthesizedExpression":this.checkLVal(a.expression,b,c);break;default:this.raise(a.start,(b?"Binding":"Assigning to")+" rvalue")}}},{"./state":10,"./tokentype":14,"./util":15}],7:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}
// Finish an AST node, adding `type` and `end` properties.
function e(a,b,c,d){return a.type=b,a.end=c,this.options.locations&&(a.loc.end=d),this.options.ranges&&(a.range[1]=c),a}c.__esModule=!0;var f=a("./state"),g=a("./locutil"),h=function j(a,b,c){d(this,j),this.type="",this.start=b,this.end=0,a.options.locations&&(this.loc=new g.SourceLocation(a,c)),a.options.directSourceFile&&(this.sourceFile=a.options.directSourceFile),a.options.ranges&&(this.range=[b,0])};c.Node=h;var i=f.Parser.prototype;i.startNode=function(){return new h(this,this.start,this.startLoc)},i.startNodeAt=function(a,b){return new h(this,a,b)},i.finishNode=function(a,b){return e.call(this,a,b,this.lastTokEnd,this.lastTokEndLoc)},
// Finish node at given position
i.finishNodeAt=function(a,b,c,d){return e.call(this,a,b,c,d)}},{"./locutil":5,"./state":10}],8:[function(a,b,c){"use strict";
// Interpret and default an options object
function d(a){var b={};for(var c in h)b[c]=a&&f.has(a,c)?a[c]:h[c];return null==b.allowReserved&&(b.allowReserved=b.ecmaVersion<5),f.isArray(b.onToken)&&!function(){var a=b.onToken;b.onToken=function(b){return a.push(b)}}(),f.isArray(b.onComment)&&(b.onComment=e(b,b.onComment)),b}function e(a,b){return function(c,d,e,f,h,i){var j={type:c?"Block":"Line",value:d,start:e,end:f};a.locations&&(j.loc=new g.SourceLocation(this,h,i)),a.ranges&&(j.range=[e,f]),b.push(j)}}c.__esModule=!0,c.getOptions=d;var f=a("./util"),g=a("./locutil"),h={
// `ecmaVersion` indicates the ECMAScript version to parse. Must
// be either 3, or 5, or 6. This influences support for strict
// mode, the set of reserved words, support for getters and
// setters and other features.
ecmaVersion:5,
// Source type ("script" or "module") for different semantics
sourceType:"script",
// `onInsertedSemicolon` can be a callback that will be called
// when a semicolon is automatically inserted. It will be passed
// th position of the comma as an offset, and if `locations` is
// enabled, it is given the location as a `{line, column}` object
// as second argument.
onInsertedSemicolon:null,
// `onTrailingComma` is similar to `onInsertedSemicolon`, but for
// trailing commas.
onTrailingComma:null,
// By default, reserved words are only enforced if ecmaVersion >= 5.
// Set `allowReserved` to a boolean value to explicitly turn this on
// an off. When this option has the value "never", reserved words
// and keywords can also not be used as property names.
allowReserved:null,
// When enabled, a return at the top level is not considered an
// error.
allowReturnOutsideFunction:!1,
// When enabled, import/export statements are not constrained to
// appearing at the top of the program.
allowImportExportEverywhere:!1,
// When enabled, hashbang directive in the beginning of file
// is allowed and treated as a line comment.
allowHashBang:!1,
// When `locations` is on, `loc` properties holding objects with
// `start` and `end` properties in `{line, column}` form (with
// line being 1-based and column 0-based) will be attached to the
// nodes.
locations:!1,
// A function can be passed as `onToken` option, which will
// cause Acorn to call that function with object in the same
// format as tokens returned from `tokenizer().getToken()`. Note
// that you are not allowed to call the parser from the
// callback—that will corrupt its internal state.
onToken:null,
// A function can be passed as `onComment` option, which will
// cause Acorn to call that function with `(block, text, start,
// end)` parameters whenever a comment is skipped. `block` is a
// boolean indicating whether this is a block (`/* */`) comment,
// `text` is the content of the comment, and `start` and `end` are
// character offsets that denote the start and end of the comment.
// When the `locations` option is on, two more parameters are
// passed, the full `{line, column}` locations of the start and
// end of the comments. Note that you are not allowed to call the
// parser from the callback—that will corrupt its internal state.
onComment:null,
// Nodes have their start and end characters offsets recorded in
// `start` and `end` properties (directly on the node, rather than
// the `loc` object, which holds line/column data. To also add a
// [semi-standardized][range] `range` property holding a `[start,
// end]` array with the same numbers, set the `ranges` option to
// `true`.
//
// [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
ranges:!1,
// It is possible to parse multiple files into a single AST by
// passing the tree produced by parsing the first file as
// `program` option in subsequent parses. This will add the
// toplevel forms of the parsed file to the `Program` (top) node
// of an existing parse tree.
program:null,
// When `locations` is on, you can pass this to record the source
// file in every node's `loc` object.
sourceFile:null,
// This value, if given, is stored in every node, whether
// `locations` is on or off.
directSourceFile:null,
// When enabled, parenthesized expressions are represented by
// (non-standard) ParenthesizedExpression nodes
preserveParens:!1,plugins:{}};c.defaultOptions=h},{"./locutil":5,"./util":15}],9:[function(a,b,c){"use strict";var d=a("./tokentype"),e=a("./state"),f=a("./whitespace"),g=e.Parser.prototype;
// ## Parser utilities
// Test whether a statement node is the string literal `"use strict"`.
g.isUseStrict=function(a){return this.options.ecmaVersion>=5&&"ExpressionStatement"===a.type&&"Literal"===a.expression.type&&"use strict"===a.expression.raw.slice(1,-1)},
// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.
g.eat=function(a){return this.type===a?(this.next(),!0):!1},
// Tests whether parsed token is a contextual keyword.
g.isContextual=function(a){return this.type===d.types.name&&this.value===a},
// Consumes contextual keyword if possible.
g.eatContextual=function(a){return this.value===a&&this.eat(d.types.name)},
// Asserts that following token is given contextual keyword.
g.expectContextual=function(a){this.eatContextual(a)||this.unexpected()},
// Test whether a semicolon can be inserted at the current position.
g.canInsertSemicolon=function(){return this.type===d.types.eof||this.type===d.types.braceR||f.lineBreak.test(this.input.slice(this.lastTokEnd,this.start))},g.insertSemicolon=function(){return this.canInsertSemicolon()?(this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0):void 0},
// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.
g.semicolon=function(){this.eat(d.types.semi)||this.insertSemicolon()||this.unexpected()},g.afterTrailingComma=function(a){return this.type==a?(this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),this.next(),!0):void 0},
// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.
g.expect=function(a){this.eat(a)||this.unexpected()},
// Raise an unexpected token error.
g.unexpected=function(a){this.raise(null!=a?a:this.start,"Unexpected token")},g.checkPatternErrors=function(a,b){var c=a&&a.trailingComma;return b?void(c&&this.raise(c,"Trailing comma is not permitted in destructuring patterns")):!!c},g.checkExpressionErrors=function(a,b){var c=a&&a.shorthandAssign;return b?void(c&&this.raise(c,"Shorthand property assignments are valid only in destructuring patterns")):!!c}},{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a){return new RegExp("^("+a.replace(/ /g,"|")+")$")}c.__esModule=!0;var f=a("./identifier"),g=a("./tokentype"),h=a("./whitespace"),i=a("./options"),j={};c.plugins=j;var k=function(){function a(b,c,j){d(this,a),this.options=b=i.getOptions(b),this.sourceFile=b.sourceFile,this.keywords=e(f.keywords[b.ecmaVersion>=6?6:5]);var k=b.allowReserved?"":f.reservedWords[b.ecmaVersion]+("module"==b.sourceType?" await":"");this.reservedWords=e(k);var l=(k?k+" ":"")+f.reservedWords.strict;this.reservedWordsStrict=e(l),this.reservedWordsStrictBind=e(l+" "+f.reservedWords.strictBind),this.input=String(c),
// Used to signal to callers of `readWord1` whether the word
// contained any escape sequences. This is needed because words with
// escape sequences must not be interpreted as keywords.
this.containsEsc=!1,
// Load plugins
this.loadPlugins(b.plugins),
// Set up token state
// The current position of the tokenizer in the input.
j?(this.pos=j,this.lineStart=Math.max(0,this.input.lastIndexOf("\n",j)),this.curLine=this.input.slice(0,this.lineStart).split(h.lineBreak).length):(this.pos=this.lineStart=0,this.curLine=1),
// Properties of the current token:
// Its type
this.type=g.types.eof,
// For tokens that include more information than their type, the value
this.value=null,
// Its start and end offset
this.start=this.end=this.pos,
// And, if locations are used, the {line, column} object
// corresponding to those offsets
this.startLoc=this.endLoc=this.curPosition(),
// Position information for the previous token
this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,
// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
// given position.
this.context=this.initialContext(),this.exprAllowed=!0,
// Figure out if it's a module code.
this.strict=this.inModule="module"===b.sourceType,
// Used to signify the start of a potential arrow function
this.potentialArrowAt=-1,
// Flags to track whether we are in a function, a generator.
this.inFunction=this.inGenerator=!1,
// Labels in scope.
this.labels=[],
// If enabled, skip leading hashbang line.
0===this.pos&&b.allowHashBang&&"#!"===this.input.slice(0,2)&&this.skipLineComment(2)}
// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
return a.prototype.isKeyword=function(a){return this.keywords.test(a)},a.prototype.isReservedWord=function(a){return this.reservedWords.test(a)},a.prototype.extend=function(a,b){this[a]=b(this[a])},a.prototype.loadPlugins=function(a){for(var b in a){var c=j[b];if(!c)throw new Error("Plugin '"+b+"' not found");c(this,a[b])}},a.prototype.parse=function(){var a=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(a)},a}();c.Parser=k},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(a,b,c){"use strict";var d=a("./tokentype"),e=a("./state"),f=a("./whitespace"),g=e.Parser.prototype;
// ### Statement parsing
// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.
g.parseTopLevel=function(a){var b=!0;for(a.body||(a.body=[]);this.type!==d.types.eof;){var c=this.parseStatement(!0,!0);a.body.push(c),b&&(this.isUseStrict(c)&&this.setStrict(!0),b=!1)}return this.next(),this.options.ecmaVersion>=6&&(a.sourceType=this.options.sourceType),this.finishNode(a,"Program")};var h={kind:"loop"},i={kind:"switch"};
// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.
g.parseStatement=function(a,b){var c=this.type,e=this.startNode();
// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.
switch(c){case d.types._break:case d.types._continue:return this.parseBreakContinueStatement(e,c.keyword);case d.types._debugger:return this.parseDebuggerStatement(e);case d.types._do:return this.parseDoStatement(e);case d.types._for:return this.parseForStatement(e);case d.types._function:return!a&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(e);case d.types._class:return a||this.unexpected(),this.parseClass(e,!0);case d.types._if:return this.parseIfStatement(e);case d.types._return:return this.parseReturnStatement(e);case d.types._switch:return this.parseSwitchStatement(e);case d.types._throw:return this.parseThrowStatement(e);case d.types._try:return this.parseTryStatement(e);case d.types._let:case d.types._const:a||this.unexpected();// NOTE: falls through to _var
case d.types._var:return this.parseVarStatement(e,c);case d.types._while:return this.parseWhileStatement(e);case d.types._with:return this.parseWithStatement(e);case d.types.braceL:return this.parseBlock();case d.types.semi:return this.parseEmptyStatement(e);case d.types._export:case d.types._import:return this.options.allowImportExportEverywhere||(b||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),c===d.types._import?this.parseImport(e):this.parseExport(e);
// If the statement does not start with a statement keyword or a
// brace, it's an ExpressionStatement or LabeledStatement. We
// simply start parsing an expression, and afterwards, if the
// next token is a colon and the expression was a simple
// Identifier node, we switch to interpreting it as a label.
default:var f=this.value,g=this.parseExpression();return c===d.types.name&&"Identifier"===g.type&&this.eat(d.types.colon)?this.parseLabeledStatement(e,f,g):this.parseExpressionStatement(e,g)}},g.parseBreakContinueStatement=function(a,b){var c="break"==b;this.next(),this.eat(d.types.semi)||this.insertSemicolon()?a.label=null:this.type!==d.types.name?this.unexpected():(a.label=this.parseIdent(),this.semicolon());
// Verify that there is an actual destination to break or
// continue to.
for(var e=0;e<this.labels.length;++e){var f=this.labels[e];if(null==a.label||f.name===a.label.name){if(null!=f.kind&&(c||"loop"===f.kind))break;if(a.label&&c)break}}return e===this.labels.length&&this.raise(a.start,"Unsyntactic "+b),this.finishNode(a,c?"BreakStatement":"ContinueStatement")},g.parseDebuggerStatement=function(a){return this.next(),this.semicolon(),this.finishNode(a,"DebuggerStatement")},g.parseDoStatement=function(a){return this.next(),this.labels.push(h),a.body=this.parseStatement(!1),this.labels.pop(),this.expect(d.types._while),a.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(d.types.semi):this.semicolon(),this.finishNode(a,"DoWhileStatement")},
// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
g.parseForStatement=function(a){if(this.next(),this.labels.push(h),this.expect(d.types.parenL),this.type===d.types.semi)return this.parseFor(a,null);if(this.type===d.types._var||this.type===d.types._let||this.type===d.types._const){var b=this.startNode(),c=this.type;return this.next(),this.parseVar(b,!0,c),this.finishNode(b,"VariableDeclaration"),!(this.type===d.types._in||this.options.ecmaVersion>=6&&this.isContextual("of"))||1!==b.declarations.length||c!==d.types._var&&b.declarations[0].init?this.parseFor(a,b):this.parseForIn(a,b)}var e={shorthandAssign:0,trailingComma:0},f=this.parseExpression(!0,e);return this.type===d.types._in||this.options.ecmaVersion>=6&&this.isContextual("of")?(this.checkPatternErrors(e,!0),this.toAssignable(f),this.checkLVal(f),this.parseForIn(a,f)):(this.checkExpressionErrors(e,!0),this.parseFor(a,f))},g.parseFunctionStatement=function(a){return this.next(),this.parseFunction(a,!0)},g.parseIfStatement=function(a){return this.next(),a.test=this.parseParenExpression(),a.consequent=this.parseStatement(!1),a.alternate=this.eat(d.types._else)?this.parseStatement(!1):null,this.finishNode(a,"IfStatement")},g.parseReturnStatement=function(a){
// In `return` (and `break`/`continue`), the keywords with
// optional arguments, we eagerly look for a semicolon or the
// possibility to insert one.
return this.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.start,"'return' outside of function"),this.next(),this.eat(d.types.semi)||this.insertSemicolon()?a.argument=null:(a.argument=this.parseExpression(),this.semicolon()),this.finishNode(a,"ReturnStatement")},g.parseSwitchStatement=function(a){this.next(),a.discriminant=this.parseParenExpression(),a.cases=[],this.expect(d.types.braceL),this.labels.push(i);
// Statements under must be grouped (by label) in SwitchCase
// nodes. `cur` is used to keep the node that we are currently
// adding statements to.
for(var b,c=!1;this.type!=d.types.braceR;)if(this.type===d.types._case||this.type===d.types._default){var e=this.type===d.types._case;b&&this.finishNode(b,"SwitchCase"),a.cases.push(b=this.startNode()),b.consequent=[],this.next(),e?b.test=this.parseExpression():(c&&this.raise(this.lastTokStart,"Multiple default clauses"),c=!0,b.test=null),this.expect(d.types.colon)}else b||this.unexpected(),b.consequent.push(this.parseStatement(!0));// Closing brace
return b&&this.finishNode(b,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(a,"SwitchStatement")},g.parseThrowStatement=function(a){return this.next(),f.lineBreak.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),a.argument=this.parseExpression(),this.semicolon(),this.finishNode(a,"ThrowStatement")};
// Reused empty array added for node fields that are always empty.
var j=[];g.parseTryStatement=function(a){if(this.next(),a.block=this.parseBlock(),a.handler=null,this.type===d.types._catch){var b=this.startNode();this.next(),this.expect(d.types.parenL),b.param=this.parseBindingAtom(),this.checkLVal(b.param,!0),this.expect(d.types.parenR),b.body=this.parseBlock(),a.handler=this.finishNode(b,"CatchClause")}return a.finalizer=this.eat(d.types._finally)?this.parseBlock():null,a.handler||a.finalizer||this.raise(a.start,"Missing catch or finally clause"),this.finishNode(a,"TryStatement")},g.parseVarStatement=function(a,b){return this.next(),this.parseVar(a,!1,b),this.semicolon(),this.finishNode(a,"VariableDeclaration")},g.parseWhileStatement=function(a){return this.next(),a.test=this.parseParenExpression(),this.labels.push(h),a.body=this.parseStatement(!1),this.labels.pop(),this.finishNode(a,"WhileStatement")},g.parseWithStatement=function(a){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),a.object=this.parseParenExpression(),a.body=this.parseStatement(!1),this.finishNode(a,"WithStatement")},g.parseEmptyStatement=function(a){return this.next(),this.finishNode(a,"EmptyStatement")},g.parseLabeledStatement=function(a,b,c){for(var e=0;e<this.labels.length;++e)this.labels[e].name===b&&this.raise(c.start,"Label '"+b+"' is already declared");for(var f=this.type.isLoop?"loop":this.type===d.types._switch?"switch":null,e=this.labels.length-1;e>=0;e--){var g=this.labels[e];if(g.statementStart!=a.start)break;g.statementStart=this.start,g.kind=f}return this.labels.push({name:b,kind:f,statementStart:this.start}),a.body=this.parseStatement(!0),this.labels.pop(),a.label=c,this.finishNode(a,"LabeledStatement")},g.parseExpressionStatement=function(a,b){return a.expression=b,this.semicolon(),this.finishNode(a,"ExpressionStatement")},
// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).
g.parseBlock=function(a){var b=this.startNode(),c=!0,e=void 0;for(b.body=[],this.expect(d.types.braceL);!this.eat(d.types.braceR);){var f=this.parseStatement(!0);b.body.push(f),c&&a&&this.isUseStrict(f)&&(e=this.strict,this.setStrict(this.strict=!0)),c=!1}return e===!1&&this.setStrict(!1),this.finishNode(b,"BlockStatement")},
// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.
g.parseFor=function(a,b){return a.init=b,this.expect(d.types.semi),a.test=this.type===d.types.semi?null:this.parseExpression(),this.expect(d.types.semi),a.update=this.type===d.types.parenR?null:this.parseExpression(),this.expect(d.types.parenR),a.body=this.parseStatement(!1),this.labels.pop(),this.finishNode(a,"ForStatement")},
// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.
g.parseForIn=function(a,b){var c=this.type===d.types._in?"ForInStatement":"ForOfStatement";return this.next(),a.left=b,a.right=this.parseExpression(),this.expect(d.types.parenR),a.body=this.parseStatement(!1),this.labels.pop(),this.finishNode(a,c)},
// Parse a list of variable declarations.
g.parseVar=function(a,b,c){for(a.declarations=[],a.kind=c.keyword;;){var e=this.startNode();if(this.parseVarId(e),this.eat(d.types.eq)?e.init=this.parseMaybeAssign(b):c!==d.types._const||this.type===d.types._in||this.options.ecmaVersion>=6&&this.isContextual("of")?"Identifier"==e.id.type||b&&(this.type===d.types._in||this.isContextual("of"))?e.init=null:this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):this.unexpected(),a.declarations.push(this.finishNode(e,"VariableDeclarator")),!this.eat(d.types.comma))break}return a},g.parseVarId=function(a){a.id=this.parseBindingAtom(),this.checkLVal(a.id,!0)},
// Parse a function declaration or literal (depending on the
// `isStatement` parameter).
g.parseFunction=function(a,b,c){return this.initFunction(a),this.options.ecmaVersion>=6&&(a.generator=this.eat(d.types.star)),(b||this.type===d.types.name)&&(a.id=this.parseIdent()),this.parseFunctionParams(a),this.parseFunctionBody(a,c),this.finishNode(a,b?"FunctionDeclaration":"FunctionExpression")},g.parseFunctionParams=function(a){this.expect(d.types.parenL),a.params=this.parseBindingList(d.types.parenR,!1,!1,!0)},
// Parse a class declaration or literal (depending on the
// `isStatement` parameter).
g.parseClass=function(a,b){this.next(),this.parseClassId(a,b),this.parseClassSuper(a);var c=this.startNode(),e=!1;for(c.body=[],this.expect(d.types.braceL);!this.eat(d.types.braceR);)if(!this.eat(d.types.semi)){var f=this.startNode(),g=this.eat(d.types.star),h=this.type===d.types.name&&"static"===this.value;this.parsePropertyName(f),f["static"]=h&&this.type!==d.types.parenL,f["static"]&&(g&&this.unexpected(),g=this.eat(d.types.star),this.parsePropertyName(f)),f.kind="method";var i=!1;if(!f.computed){var j=f.key;g||"Identifier"!==j.type||this.type===d.types.parenL||"get"!==j.name&&"set"!==j.name||(i=!0,f.kind=j.name,j=this.parsePropertyName(f)),!f["static"]&&("Identifier"===j.type&&"constructor"===j.name||"Literal"===j.type&&"constructor"===j.value)&&(e&&this.raise(j.start,"Duplicate constructor in the same class"),i&&this.raise(j.start,"Constructor can't have get/set modifier"),g&&this.raise(j.start,"Constructor can't be a generator"),f.kind="constructor",e=!0)}if(this.parseClassMethod(c,f,g),i){var k="get"===f.kind?0:1;if(f.value.params.length!==k){var l=f.value.start;"get"===f.kind?this.raise(l,"getter should have no params"):this.raise(l,"setter should have exactly one param")}}}return a.body=this.finishNode(c,"ClassBody"),this.finishNode(a,b?"ClassDeclaration":"ClassExpression")},g.parseClassMethod=function(a,b,c){b.value=this.parseMethod(c),a.body.push(this.finishNode(b,"MethodDefinition"))},g.parseClassId=function(a,b){a.id=this.type===d.types.name?this.parseIdent():b?this.unexpected():null},g.parseClassSuper=function(a){a.superClass=this.eat(d.types._extends)?this.parseExprSubscripts():null},
// Parses module export declaration.
g.parseExport=function(a){
// export * from '...'
if(this.next(),this.eat(d.types.star))return this.expectContextual("from"),a.source=this.type===d.types.string?this.parseExprAtom():this.unexpected(),this.semicolon(),this.finishNode(a,"ExportAllDeclaration");if(this.eat(d.types._default)){
// export default ...
var b=this.parseMaybeAssign(),c=!0;return("FunctionExpression"==b.type||"ClassExpression"==b.type)&&(c=!1,b.id&&(b.type="FunctionExpression"==b.type?"FunctionDeclaration":"ClassDeclaration")),a.declaration=b,c&&this.semicolon(),this.finishNode(a,"ExportDefaultDeclaration")}
// export var|const|let|function|class ...
if(this.shouldParseExportStatement())a.declaration=this.parseStatement(!0),a.specifiers=[],a.source=null;else{if(
// export { x, y as z } [from '...']
a.declaration=null,a.specifiers=this.parseExportSpecifiers(),this.eatContextual("from"))a.source=this.type===d.types.string?this.parseExprAtom():this.unexpected();else{
// check for keywords used as local names
for(var e=0;e<a.specifiers.length;e++)(this.keywords.test(a.specifiers[e].local.name)||this.reservedWords.test(a.specifiers[e].local.name))&&this.unexpected(a.specifiers[e].local.start);a.source=null}this.semicolon()}return this.finishNode(a,"ExportNamedDeclaration")},g.shouldParseExportStatement=function(){return this.type.keyword},
// Parses a comma-separated list of module exports.
g.parseExportSpecifiers=function(){var a=[],b=!0;for(
// export { x, y as z } [from '...']
this.expect(d.types.braceL);!this.eat(d.types.braceR);){if(b)b=!1;else if(this.expect(d.types.comma),this.afterTrailingComma(d.types.braceR))break;var c=this.startNode();c.local=this.parseIdent(this.type===d.types._default),c.exported=this.eatContextual("as")?this.parseIdent(!0):c.local,a.push(this.finishNode(c,"ExportSpecifier"))}return a},
// Parses import declaration.
g.parseImport=function(a){
// import '...'
return this.next(),this.type===d.types.string?(a.specifiers=j,a.source=this.parseExprAtom()):(a.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),a.source=this.type===d.types.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(a,"ImportDeclaration")},
// Parses a comma-separated list of module imports.
g.parseImportSpecifiers=function(){var a=[],b=!0;if(this.type===d.types.name){
// import defaultObj, { x, y as z } from '...'
var c=this.startNode();if(c.local=this.parseIdent(),this.checkLVal(c.local,!0),a.push(this.finishNode(c,"ImportDefaultSpecifier")),!this.eat(d.types.comma))return a}if(this.type===d.types.star){var c=this.startNode();return this.next(),this.expectContextual("as"),c.local=this.parseIdent(),this.checkLVal(c.local,!0),a.push(this.finishNode(c,"ImportNamespaceSpecifier")),a}for(this.expect(d.types.braceL);!this.eat(d.types.braceR);){if(b)b=!1;else if(this.expect(d.types.comma),this.afterTrailingComma(d.types.braceR))break;var c=this.startNode();c.imported=this.parseIdent(!0),c.local=this.eatContextual("as")?this.parseIdent():c.imported,this.checkLVal(c.local,!0),a.push(this.finishNode(c,"ImportSpecifier"))}return a}},{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(a,b,c){
// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design
"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}c.__esModule=!0;var e=a("./state"),f=a("./tokentype"),g=a("./whitespace"),h=function k(a,b,c,e){d(this,k),this.token=a,this.isExpr=!!b,this.preserveSpace=!!c,this.override=e};c.TokContext=h;var i={b_stat:new h("{",!1),b_expr:new h("{",!0),b_tmpl:new h("${",!0),p_stat:new h("(",!1),p_expr:new h("(",!0),q_tmpl:new h("`",!0,!0,function(a){return a.readTmplToken()}),f_expr:new h("function",!0)};c.types=i;var j=e.Parser.prototype;j.initialContext=function(){return[i.b_stat]},j.braceIsBlock=function(a){if(a===f.types.colon){var b=this.curContext();if(b===i.b_stat||b===i.b_expr)return!b.isExpr}return a===f.types._return?g.lineBreak.test(this.input.slice(this.lastTokEnd,this.start)):a===f.types._else||a===f.types.semi||a===f.types.eof||a===f.types.parenR?!0:a==f.types.braceL?this.curContext()===i.b_stat:!this.exprAllowed},j.updateContext=function(a){var b=void 0,c=this.type;c.keyword&&a==f.types.dot?this.exprAllowed=!1:(b=c.updateContext)?b.call(this,a):this.exprAllowed=c.beforeExpr},
// Token-specific context update code
f.types.parenR.updateContext=f.types.braceR.updateContext=function(){if(1==this.context.length)return void(this.exprAllowed=!0);var a=this.context.pop();a===i.b_stat&&this.curContext()===i.f_expr?(this.context.pop(),this.exprAllowed=!1):a===i.b_tmpl?this.exprAllowed=!0:this.exprAllowed=!a.isExpr},f.types.braceL.updateContext=function(a){this.context.push(this.braceIsBlock(a)?i.b_stat:i.b_expr),this.exprAllowed=!0},f.types.dollarBraceL.updateContext=function(){this.context.push(i.b_tmpl),this.exprAllowed=!0},f.types.parenL.updateContext=function(a){var b=a===f.types._if||a===f.types._for||a===f.types._with||a===f.types._while;this.context.push(b?i.p_stat:i.p_expr),this.exprAllowed=!0},f.types.incDec.updateContext=function(){},f.types._function.updateContext=function(){this.curContext()!==i.b_stat&&this.context.push(i.f_expr),this.exprAllowed=!1},f.types.backQuote.updateContext=function(){this.curContext()===i.q_tmpl?this.context.pop():this.context.push(i.q_tmpl),this.exprAllowed=!1}},{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}
// Parse a regular expression. Some context-awareness is necessary,
// since a '/' inside a '[]' set does not end the expression.
function e(a,b,c,d){try{return new RegExp(a,b)}catch(e){if(void 0!==c)throw e instanceof SyntaxError&&d.raise(c,"Error parsing regular expression: "+e.message),e}}function f(a){
// UTF-16 Decoding
// UTF-16 Decoding
return 65535>=a?String.fromCharCode(a):(a-=65536,String.fromCharCode((a>>10)+55296,(1023&a)+56320))}c.__esModule=!0;var g=a("./identifier"),h=a("./tokentype"),i=a("./state"),j=a("./locutil"),k=a("./whitespace"),l=function p(a){d(this,p),this.type=a.type,this.value=a.value,this.start=a.start,this.end=a.end,a.options.locations&&(this.loc=new j.SourceLocation(a,a.startLoc,a.endLoc)),a.options.ranges&&(this.range=[a.start,a.end])};c.Token=l;var m=i.Parser.prototype,n="object"==typeof Packages&&"[object JavaPackage]"==Object.prototype.toString.call(Packages);
// Move to the next token
m.next=function(){this.options.onToken&&this.options.onToken(new l(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},m.getToken=function(){return this.next(),new l(this)},
// If we're in an ES6 environment, make parsers iterable
"undefined"!=typeof Symbol&&(m[Symbol.iterator]=function(){var a=this;return{next:function(){var b=a.getToken();return{done:b.type===h.types.eof,value:b}}}}),
// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).
m.setStrict=function(a){if(this.strict=a,this.type===h.types.num||this.type===h.types.string){if(this.pos=this.start,this.options.locations)for(;this.pos<this.lineStart;)this.lineStart=this.input.lastIndexOf("\n",this.lineStart-2)+1,--this.curLine;this.nextToken()}},m.curContext=function(){return this.context[this.context.length-1]},
// Read a single token, updating the parser object's token-related
// properties.
m.nextToken=function(){var a=this.curContext();return a&&a.preserveSpace||this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length?this.finishToken(h.types.eof):a.override?a.override(this):void this.readToken(this.fullCharCodeAtPos())},m.readToken=function(a){
// Identifier or keyword. '\uXXXX' sequences are allowed in
// identifiers, so '\' also dispatches to that.
// Identifier or keyword. '\uXXXX' sequences are allowed in
// identifiers, so '\' also dispatches to that.
return g.isIdentifierStart(a,this.options.ecmaVersion>=6)||92===a?this.readWord():this.getTokenFromCode(a)},m.fullCharCodeAtPos=function(){var a=this.input.charCodeAt(this.pos);if(55295>=a||a>=57344)return a;var b=this.input.charCodeAt(this.pos+1);return(a<<10)+b-56613888},m.skipBlockComment=function(){var a=this.options.onComment&&this.curPosition(),b=this.pos,c=this.input.indexOf("*/",this.pos+=2);if(-1===c&&this.raise(this.pos-2,"Unterminated comment"),this.pos=c+2,this.options.locations){k.lineBreakG.lastIndex=b;for(var d=void 0;(d=k.lineBreakG.exec(this.input))&&d.index<this.pos;)++this.curLine,this.lineStart=d.index+d[0].length}this.options.onComment&&this.options.onComment(!0,this.input.slice(b+2,c),b,this.pos,a,this.curPosition())},m.skipLineComment=function(a){for(var b=this.pos,c=this.options.onComment&&this.curPosition(),d=this.input.charCodeAt(this.pos+=a);this.pos<this.input.length&&10!==d&&13!==d&&8232!==d&&8233!==d;)++this.pos,d=this.input.charCodeAt(this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(b+a,this.pos),b,this.pos,c,this.curPosition())},
// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.
m.skipSpace=function(){a:for(;this.pos<this.input.length;){var a=this.input.charCodeAt(this.pos);switch(a){case 32:case 160:
// ' '
++this.pos;break;case 13:10===this.input.charCodeAt(this.pos+1)&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:
// '/'
switch(this.input.charCodeAt(this.pos+1)){case 42:
// '*'
this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break a}break;default:if(!(a>8&&14>a||a>=5760&&k.nonASCIIwhitespace.test(String.fromCharCode(a))))break a;++this.pos}}},
// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.
m.finishToken=function(a,b){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var c=this.type;this.type=a,this.value=b,this.updateContext(c)},
// ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
m.readToken_dot=function(){var a=this.input.charCodeAt(this.pos+1);if(a>=48&&57>=a)return this.readNumber(!0);var b=this.input.charCodeAt(this.pos+2);
// 46 = dot '.'
return this.options.ecmaVersion>=6&&46===a&&46===b?(this.pos+=3,this.finishToken(h.types.ellipsis)):(++this.pos,this.finishToken(h.types.dot))},m.readToken_slash=function(){
// '/'
var a=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):61===a?this.finishOp(h.types.assign,2):this.finishOp(h.types.slash,1)},m.readToken_mult_modulo=function(a){
// '%*'
var b=this.input.charCodeAt(this.pos+1);return 61===b?this.finishOp(h.types.assign,2):this.finishOp(42===a?h.types.star:h.types.modulo,1)},m.readToken_pipe_amp=function(a){
// '|&'
var b=this.input.charCodeAt(this.pos+1);return b===a?this.finishOp(124===a?h.types.logicalOR:h.types.logicalAND,2):61===b?this.finishOp(h.types.assign,2):this.finishOp(124===a?h.types.bitwiseOR:h.types.bitwiseAND,1)},m.readToken_caret=function(){
// '^'
var a=this.input.charCodeAt(this.pos+1);return 61===a?this.finishOp(h.types.assign,2):this.finishOp(h.types.bitwiseXOR,1)},m.readToken_plus_min=function(a){
// '+-'
var b=this.input.charCodeAt(this.pos+1);
// A `-->` line comment
return b===a?45==b&&62==this.input.charCodeAt(this.pos+2)&&k.lineBreak.test(this.input.slice(this.lastTokEnd,this.pos))?(this.skipLineComment(3),this.skipSpace(),this.nextToken()):this.finishOp(h.types.incDec,2):61===b?this.finishOp(h.types.assign,2):this.finishOp(h.types.plusMin,1)},m.readToken_lt_gt=function(a){
// '<>'
var b=this.input.charCodeAt(this.pos+1),c=1;
// `<!--`, an XML-style comment that should be interpreted as a line comment
return b===a?(c=62===a&&62===this.input.charCodeAt(this.pos+2)?3:2,61===this.input.charCodeAt(this.pos+c)?this.finishOp(h.types.assign,c+1):this.finishOp(h.types.bitShift,c)):33==b&&60==a&&45==this.input.charCodeAt(this.pos+2)&&45==this.input.charCodeAt(this.pos+3)?(this.inModule&&this.unexpected(),this.skipLineComment(4),this.skipSpace(),this.nextToken()):(61===b&&(c=61===this.input.charCodeAt(this.pos+2)?3:2),this.finishOp(h.types.relational,c))},m.readToken_eq_excl=function(a){
// '=!'
var b=this.input.charCodeAt(this.pos+1);
// '=>'
return 61===b?this.finishOp(h.types.equality,61===this.input.charCodeAt(this.pos+2)?3:2):61===a&&62===b&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(h.types.arrow)):this.finishOp(61===a?h.types.eq:h.types.prefix,1)},m.getTokenFromCode=function(a){switch(a){
// The interpretation of a dot depends on whether it is followed
// by a digit or another two dots.
case 46:
// '.'
return this.readToken_dot();
// Punctuation tokens.
case 40:return++this.pos,this.finishToken(h.types.parenL);case 41:return++this.pos,this.finishToken(h.types.parenR);case 59:return++this.pos,this.finishToken(h.types.semi);case 44:return++this.pos,this.finishToken(h.types.comma);case 91:return++this.pos,this.finishToken(h.types.bracketL);case 93:return++this.pos,this.finishToken(h.types.bracketR);case 123:return++this.pos,this.finishToken(h.types.braceL);case 125:return++this.pos,this.finishToken(h.types.braceR);case 58:return++this.pos,this.finishToken(h.types.colon);case 63:return++this.pos,this.finishToken(h.types.question);case 96:
// '`'
if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(h.types.backQuote);case 48:
// '0'
var b=this.input.charCodeAt(this.pos+1);if(120===b||88===b)return this.readRadixNumber(16);// '0x', '0X' - hex number
if(this.options.ecmaVersion>=6){if(111===b||79===b)return this.readRadixNumber(8);// '0o', '0O' - octal number
if(98===b||66===b)return this.readRadixNumber(2)}
// Anything else beginning with a digit is an integer, octal
// number, or float.
case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
// 1-9
return this.readNumber(!1);
// Quotes produce strings.
case 34:case 39:
// '"', "'"
return this.readString(a);
// Operators are parsed inline in tiny state machines. '=' (61) is
// often referred to. `finishOp` simply skips the amount of
// characters it is given as second argument, and returns a token
// of the type given by its first argument.
case 47:
// '/'
return this.readToken_slash();case 37:case 42:
// '%*'
return this.readToken_mult_modulo(a);case 124:case 38:
// '|&'
return this.readToken_pipe_amp(a);case 94:
// '^'
return this.readToken_caret();case 43:case 45:
// '+-'
return this.readToken_plus_min(a);case 60:case 62:
// '<>'
return this.readToken_lt_gt(a);case 61:case 33:
// '=!'
return this.readToken_eq_excl(a);case 126:
// '~'
return this.finishOp(h.types.prefix,1)}this.raise(this.pos,"Unexpected character '"+f(a)+"'")},m.finishOp=function(a,b){var c=this.input.slice(this.pos,this.pos+b);return this.pos+=b,this.finishToken(a,c)};var o=!!e("￿","u");m.readRegexp=function(){for(var a=this,b=void 0,c=void 0,d=this.pos;;){this.pos>=this.input.length&&this.raise(d,"Unterminated regular expression");var f=this.input.charAt(this.pos);if(k.lineBreak.test(f)&&this.raise(d,"Unterminated regular expression"),b)b=!1;else{if("["===f)c=!0;else if("]"===f&&c)c=!1;else if("/"===f&&!c)break;b="\\"===f}++this.pos}var g=this.input.slice(d,this.pos);++this.pos;
// Need to use `readWord1` because '\uXXXX' sequences are allowed
// here (don't ask).
var i=this.readWord1(),j=g;if(i){var l=/^[gmsiy]*$/;this.options.ecmaVersion>=6&&(l=/^[gmsiyu]*$/),l.test(i)||this.raise(d,"Invalid regular expression flag"),i.indexOf("u")>=0&&!o&&(j=j.replace(/\\u\{([0-9a-fA-F]+)\}/g,function(b,c,e){return c=Number("0x"+c),c>1114111&&a.raise(d+e+3,"Code point out of bounds"),"x"}),j=j.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,"x"))}
// Detect invalid regular expressions.
var m=null;
// Rhino's regular expression parser is flaky and throws uncatchable exceptions,
// so don't do detection if we are running under Rhino
// Get a regular expression object for this pattern-flag pair, or `null` in
// case the current environment doesn't support the flags it uses.
return n||(e(j,void 0,d,this),m=e(g,i)),this.finishToken(h.types.regexp,{pattern:g,flags:i,value:m})},
// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.
m.readInt=function(a,b){for(var c=this.pos,d=0,e=0,f=null==b?1/0:b;f>e;++e){var g=this.input.charCodeAt(this.pos),h=void 0;if(h=g>=97?g-97+10:g>=65?g-65+10:g>=48&&57>=g?g-48:1/0,h>=a)break;++this.pos,d=d*a+h}return this.pos===c||null!=b&&this.pos-c!==b?null:d},m.readRadixNumber=function(a){this.pos+=2;// 0x
var b=this.readInt(a);return null==b&&this.raise(this.start+2,"Expected number in radix "+a),g.isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(h.types.num,b)},
// Read an integer, octal integer, or floating-point number.
m.readNumber=function(a){var b=this.pos,c=!1,d=48===this.input.charCodeAt(this.pos);a||null!==this.readInt(10)||this.raise(b,"Invalid number");var e=this.input.charCodeAt(this.pos);46===e&&(
// '.'
++this.pos,this.readInt(10),c=!0,e=this.input.charCodeAt(this.pos)),(69===e||101===e)&&(e=this.input.charCodeAt(++this.pos),(43===e||45===e)&&++this.pos,null===this.readInt(10)&&this.raise(b,"Invalid number"),c=!0),g.isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var f=this.input.slice(b,this.pos),i=void 0;return c?i=parseFloat(f):d&&1!==f.length?/[89]/.test(f)||this.strict?this.raise(b,"Invalid number"):i=parseInt(f,8):i=parseInt(f,10),this.finishToken(h.types.num,i)},
// Read a string value, interpreting backslash-escapes.
m.readCodePoint=function(){var a=this.input.charCodeAt(this.pos),b=void 0;if(123===a){this.options.ecmaVersion<6&&this.unexpected();var c=++this.pos;b=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,b>1114111&&this.raise(c,"Code point out of bounds")}else b=this.readHexChar(4);return b},m.readString=function(a){for(var b="",c=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var d=this.input.charCodeAt(this.pos);if(d===a)break;92===d?(b+=this.input.slice(c,this.pos),b+=this.readEscapedChar(!1),c=this.pos):(k.isNewLine(d)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return b+=this.input.slice(c,this.pos++),this.finishToken(h.types.string,b)},
// Reads template string tokens.
m.readTmplToken=function(){for(var a="",b=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var c=this.input.charCodeAt(this.pos);if(96===c||36===c&&123===this.input.charCodeAt(this.pos+1))
// '`', '${'
// '`', '${'
return this.pos===this.start&&this.type===h.types.template?36===c?(this.pos+=2,this.finishToken(h.types.dollarBraceL)):(++this.pos,this.finishToken(h.types.backQuote)):(a+=this.input.slice(b,this.pos),this.finishToken(h.types.template,a));if(92===c)a+=this.input.slice(b,this.pos),a+=this.readEscapedChar(!0),b=this.pos;else if(k.isNewLine(c)){switch(a+=this.input.slice(b,this.pos),++this.pos,c){case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:a+="\n";break;default:a+=String.fromCharCode(c)}this.options.locations&&(++this.curLine,this.lineStart=this.pos),b=this.pos}else++this.pos}},
// Used to read escaped characters
m.readEscapedChar=function(a){var b=this.input.charCodeAt(++this.pos);switch(++this.pos,b){case 110:return"\n";// 'n' -> '\n'
case 114:return"\r";// 'r' -> '\r'
case 120:return String.fromCharCode(this.readHexChar(2));// 'x'
case 117:return f(this.readCodePoint());// 'u'
case 116:return"	";// 't' -> '\t'
case 98:return"\b";// 'b' -> '\b'
case 118:return"";// 'v' -> '\u000b'
case 102:return"\f";// 'f' -> '\f'
case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;// '\r\n'
case 10:
// ' \n'
return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";default:if(b>=48&&55>=b){var c=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],d=parseInt(c,8);return d>255&&(c=c.slice(0,-1),d=parseInt(c,8)),d>0&&(this.strict||a)&&this.raise(this.pos-2,"Octal literal in strict mode"),this.pos+=c.length-1,String.fromCharCode(d)}return String.fromCharCode(b)}},
// Used to read character escape sequences ('\x', '\u', '\U').
m.readHexChar=function(a){var b=this.pos,c=this.readInt(16,a);return null===c&&this.raise(b,"Bad character escape sequence"),c},
// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.
m.readWord1=function(){this.containsEsc=!1;for(var a="",b=!0,c=this.pos,d=this.options.ecmaVersion>=6;this.pos<this.input.length;){var e=this.fullCharCodeAtPos();if(g.isIdentifierChar(e,d))this.pos+=65535>=e?1:2;else{if(92!==e)break;
// "\"
this.containsEsc=!0,a+=this.input.slice(c,this.pos);var h=this.pos;117!=this.input.charCodeAt(++this.pos)&&// "u"
this.raise(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var i=this.readCodePoint();(b?g.isIdentifierStart:g.isIdentifierChar)(i,d)||this.raise(h,"Invalid Unicode escape"),a+=f(i),c=this.pos}b=!1}return a+this.input.slice(c,this.pos)},
// Read an identifier or keyword token. Will check for reserved
// words when necessary.
m.readWord=function(){var a=this.readWord1(),b=h.types.name;return(this.options.ecmaVersion>=6||!this.containsEsc)&&this.keywords.test(a)&&(b=h.keywords[a]),this.finishToken(b,a)}},{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(a,b,c){
// ## Token types
// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.
// All token type variables start with an underscore, to make them
// easy to recognize.
// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.
"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a,b){return new g(a,{beforeExpr:!0,binop:b})}
// Succinct definitions of keyword token types
function f(a){var b=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];b.keyword=a,k[a]=j["_"+a]=new g(a,b)}c.__esModule=!0;var g=function l(a){var b=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];d(this,l),this.label=a,this.keyword=b.keyword,this.beforeExpr=!!b.beforeExpr,this.startsExpr=!!b.startsExpr,this.isLoop=!!b.isLoop,this.isAssign=!!b.isAssign,this.prefix=!!b.prefix,this.postfix=!!b.postfix,this.binop=b.binop||null,this.updateContext=null};c.TokenType=g;var h={beforeExpr:!0},i={startsExpr:!0},j={num:new g("num",i),regexp:new g("regexp",i),string:new g("string",i),name:new g("name",i),eof:new g("eof"),
// Punctuation token types.
bracketL:new g("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new g("]"),braceL:new g("{",{beforeExpr:!0,startsExpr:!0}),braceR:new g("}"),parenL:new g("(",{beforeExpr:!0,startsExpr:!0}),parenR:new g(")"),comma:new g(",",h),semi:new g(";",h),colon:new g(":",h),dot:new g("."),question:new g("?",h),arrow:new g("=>",h),template:new g("template"),ellipsis:new g("...",h),backQuote:new g("`",i),dollarBraceL:new g("${",{beforeExpr:!0,startsExpr:!0}),
// Operators. These carry several kinds of properties to help the
// parser use them properly (the presence of these properties is
// what categorizes them as operators).
//
// `binop`, when present, specifies that this operator is a binary
// operator, and will refer to its precedence.
//
// `prefix` and `postfix` mark the operator as a prefix or postfix
// unary operator.
//
// `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
// binary operators with a very low precedence, that should result
// in AssignmentExpression nodes.
eq:new g("=",{beforeExpr:!0,isAssign:!0}),assign:new g("_=",{beforeExpr:!0,isAssign:!0}),incDec:new g("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new g("prefix",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:e("||",1),logicalAND:e("&&",2),bitwiseOR:e("|",3),bitwiseXOR:e("^",4),bitwiseAND:e("&",5),equality:e("==/!=",6),relational:e("</>",7),bitShift:e("<</>>",8),plusMin:new g("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:e("%",10),star:e("*",10),slash:e("/",10)};c.types=j;
// Map keyword names to token types.
var k={};c.keywords=k,f("break"),f("case",h),f("catch"),f("continue"),f("debugger"),f("default",h),f("do",{isLoop:!0,beforeExpr:!0}),f("else",h),f("finally"),f("for",{isLoop:!0}),f("function",i),f("if"),f("return",h),f("switch"),f("throw",h),f("try"),f("var"),f("let"),f("const"),f("while",{isLoop:!0}),f("with"),f("new",{beforeExpr:!0,startsExpr:!0}),f("this",i),f("super",i),f("class"),f("extends",h),f("export"),f("import"),f("yield",{beforeExpr:!0,startsExpr:!0}),f("null",i),f("true",i),f("false",i),f("in",{beforeExpr:!0,binop:7}),f("instanceof",{beforeExpr:!0,binop:7}),f("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),f("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),f("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},{}],15:[function(a,b,c){"use strict";function d(a){return"[object Array]"===Object.prototype.toString.call(a)}
// Checks if an object has a property.
function e(a,b){return Object.prototype.hasOwnProperty.call(a,b)}c.__esModule=!0,c.isArray=d,c.has=e},{}],16:[function(a,b,c){
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.
"use strict";function d(a){return 10===a||13===a||8232===a||8233==a}c.__esModule=!0,c.isNewLine=d;var e=/\r\n?|\n|\u2028|\u2029/;c.lineBreak=e;var f=new RegExp(e.source,"g");c.lineBreakG=f;var g=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;c.nonASCIIwhitespace=g},{}]},{},[3])(3)})}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],40:[function(a,b,c){(function(d){!function(a){if("object"==typeof c&&"undefined"!=typeof b)b.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof d?d:"undefined"!=typeof self?self:this,(e.acorn||(e.acorn={})).walk=a()}}(function(){return function b(c,d,e){function f(h,i){if(!d[h]){if(!c[h]){var j="function"==typeof a&&a;if(!i&&j)return j(h,!0);if(g)return g(h,!0);var k=new Error("Cannot find module '"+h+"'");throw k.code="MODULE_NOT_FOUND",k}var l=d[h]={exports:{}};c[h][0].call(l.exports,function(a){var b=c[h][1][a];return f(b?b:a)},l,l.exports,b,c,d,e)}return d[h].exports}for(var g="function"==typeof a&&a,h=0;h<e.length;h++)f(e[h]);return f}({1:[function(a,b,c){
// AST walker module for Mozilla Parser API compatible trees
// A simple walk is one where you simply specify callbacks to be
// called on specific nodes. The last two arguments are optional. A
// simple use would be
//
//     walk.simple(myTree, {
//         Expression: function(node) { ... }
//     });
//
// to do something with all expressions. All Parser API node types
// can be used to identify node types, as well as Expression,
// Statement, and ScopeBody, which denote categories of nodes.
//
// The base argument can be used to pass a custom (recursive)
// walker, and state can be used to give this walked an initial
// state.
"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a,b,d,e,f){d||(d=c.base),function g(a,c,e){var f=e||a.type,h=b[f];d[f](a,c,g),h&&h(a,c)}(a,e,f)}
// An ancestor walk builds up an array of ancestor nodes (including
// the current node) and passes them to the callback as the state parameter.
function f(a,b,d,e){d||(d=c.base),e||(e=[]),function f(a,c,e){var g=e||a.type,h=b[g];a!=c[c.length-1]&&(c=c.slice(),c.push(a)),d[g](a,c,f),h&&h(a,c)}(a,e)}
// A recursive walk is one where your functions override the default
// walkers. They can modify and replace the state parameter that's
// threaded through the walk, and can opt how and whether to walk
// their child nodes (by calling their third argument on these
// nodes).
function g(a,b,d,e,f){var g=d?c.make(d,e):e;!function h(a,b,c){g[c||a.type](a,b,h)}(a,b,f)}function h(a){return"string"==typeof a?function(b){return b==a}:a?a:function(){return!0}}function i(a,b,d,e,f,g){e=h(e),f||(f=c.base);try{!function j(a,c,g){var h=g||a.type;if((null==b||a.start<=b)&&(null==d||a.end>=d)&&f[h](a,c,j),(null==b||a.start==b)&&(null==d||a.end==d)&&e(h,a))throw new p(a,c)}(a,g)}catch(i){if(i instanceof p)return i;throw i}}
// Find the innermost node of a given type that contains the given
// position. Interface similar to findNodeAt.
function j(a,b,d,e,f){d=h(d),e||(e=c.base);try{!function i(a,c,f){var g=f||a.type;if(!(a.start>b||a.end<b)&&(e[g](a,c,i),d(g,a)))throw new p(a,c)}(a,f)}catch(g){if(g instanceof p)return g;throw g}}
// Find the outermost matching node after a given position.
function k(a,b,d,e,f){d=h(d),e||(e=c.base);try{!function i(a,c,f){if(!(a.end<b)){var g=f||a.type;if(a.start>=b&&d(g,a))throw new p(a,c);e[g](a,c,i)}}(a,f)}catch(g){if(g instanceof p)return g;throw g}}
// Find the outermost matching node before a given position.
function l(a,b,d,e,f){d=h(d),e||(e=c.base);var g=void 0;return function i(a,c,f){if(!(a.start>b)){var h=f||a.type;a.end<=b&&(!g||g.node.end<a.end)&&d(h,a)&&(g=new p(a,c)),e[h](a,c,i)}}(a,f),g}
// Used to create a custom walker. Will fill in all missing node
// type properties with the defaults.
function m(a,b){b||(b=c.base);var d={};for(var e in b)d[e]=b[e];for(var e in a)d[e]=a[e];return d}function n(a,b,c){c(a,b)}function o(a,b,c){}c.__esModule=!0,c.simple=e,c.ancestor=f,c.recursive=g,c.findNodeAt=i,c.findNodeAround=j,c.findNodeAfter=k,c.findNodeBefore=l,c.make=m;var p=function r(a,b){d(this,r),this.node=a,this.state=b},q={};c.base=q,q.Program=q.BlockStatement=function(a,b,c){for(var d=0;d<a.body.length;++d)c(a.body[d],b,"Statement")},q.Statement=n,q.EmptyStatement=o,q.ExpressionStatement=q.ParenthesizedExpression=function(a,b,c){return c(a.expression,b,"Expression")},q.IfStatement=function(a,b,c){c(a.test,b,"Expression"),c(a.consequent,b,"Statement"),a.alternate&&c(a.alternate,b,"Statement")},q.LabeledStatement=function(a,b,c){return c(a.body,b,"Statement")},q.BreakStatement=q.ContinueStatement=o,q.WithStatement=function(a,b,c){c(a.object,b,"Expression"),c(a.body,b,"Statement")},q.SwitchStatement=function(a,b,c){c(a.discriminant,b,"Expression");for(var d=0;d<a.cases.length;++d){var e=a.cases[d];e.test&&c(e.test,b,"Expression");for(var f=0;f<e.consequent.length;++f)c(e.consequent[f],b,"Statement")}},q.ReturnStatement=q.YieldExpression=function(a,b,c){a.argument&&c(a.argument,b,"Expression")},q.ThrowStatement=q.SpreadElement=function(a,b,c){return c(a.argument,b,"Expression")},q.TryStatement=function(a,b,c){c(a.block,b,"Statement"),a.handler&&(c(a.handler.param,b,"Pattern"),c(a.handler.body,b,"ScopeBody")),a.finalizer&&c(a.finalizer,b,"Statement")},q.WhileStatement=q.DoWhileStatement=function(a,b,c){c(a.test,b,"Expression"),c(a.body,b,"Statement")},q.ForStatement=function(a,b,c){a.init&&c(a.init,b,"ForInit"),a.test&&c(a.test,b,"Expression"),a.update&&c(a.update,b,"Expression"),c(a.body,b,"Statement")},q.ForInStatement=q.ForOfStatement=function(a,b,c){c(a.left,b,"ForInit"),c(a.right,b,"Expression"),c(a.body,b,"Statement")},q.ForInit=function(a,b,c){"VariableDeclaration"==a.type?c(a,b):c(a,b,"Expression")},q.DebuggerStatement=o,q.FunctionDeclaration=function(a,b,c){return c(a,b,"Function")},q.VariableDeclaration=function(a,b,c){for(var d=0;d<a.declarations.length;++d)c(a.declarations[d],b)},q.VariableDeclarator=function(a,b,c){c(a.id,b,"Pattern"),a.init&&c(a.init,b,"Expression")},q.Function=function(a,b,c){a.id&&c(a.id,b,"Pattern");for(var d=0;d<a.params.length;d++)c(a.params[d],b,"Pattern");c(a.body,b,a.expression?"ScopeExpression":"ScopeBody")},
// FIXME drop these node types in next major version
// (They are awkward, and in ES6 every block can be a scope.)
q.ScopeBody=function(a,b,c){return c(a,b,"Statement")},q.ScopeExpression=function(a,b,c){return c(a,b,"Expression")},q.Pattern=function(a,b,c){"Identifier"==a.type?c(a,b,"VariablePattern"):"MemberExpression"==a.type?c(a,b,"MemberPattern"):c(a,b)},q.VariablePattern=o,q.MemberPattern=n,q.RestElement=function(a,b,c){return c(a.argument,b,"Pattern")},q.ArrayPattern=function(a,b,c){for(var d=0;d<a.elements.length;++d){var e=a.elements[d];e&&c(e,b,"Pattern")}},q.ObjectPattern=function(a,b,c){for(var d=0;d<a.properties.length;++d)c(a.properties[d].value,b,"Pattern")},q.Expression=n,q.ThisExpression=q.Super=q.MetaProperty=o,q.ArrayExpression=function(a,b,c){for(var d=0;d<a.elements.length;++d){var e=a.elements[d];e&&c(e,b,"Expression")}},q.ObjectExpression=function(a,b,c){for(var d=0;d<a.properties.length;++d)c(a.properties[d],b)},q.FunctionExpression=q.ArrowFunctionExpression=q.FunctionDeclaration,q.SequenceExpression=q.TemplateLiteral=function(a,b,c){for(var d=0;d<a.expressions.length;++d)c(a.expressions[d],b,"Expression")},q.UnaryExpression=q.UpdateExpression=function(a,b,c){c(a.argument,b,"Expression")},q.BinaryExpression=q.LogicalExpression=function(a,b,c){c(a.left,b,"Expression"),c(a.right,b,"Expression")},q.AssignmentExpression=q.AssignmentPattern=function(a,b,c){c(a.left,b,"Pattern"),c(a.right,b,"Expression")},q.ConditionalExpression=function(a,b,c){c(a.test,b,"Expression"),c(a.consequent,b,"Expression"),c(a.alternate,b,"Expression")},q.NewExpression=q.CallExpression=function(a,b,c){if(c(a.callee,b,"Expression"),a.arguments)for(var d=0;d<a.arguments.length;++d)c(a.arguments[d],b,"Expression")},q.MemberExpression=function(a,b,c){c(a.object,b,"Expression"),a.computed&&c(a.property,b,"Expression")},q.ExportNamedDeclaration=q.ExportDefaultDeclaration=function(a,b,c){a.declaration&&c(a.declaration,b,"ExportNamedDeclaration"==a.type||a.declaration.id?"Statement":"Expression"),a.source&&c(a.source,b,"Expression")},q.ExportAllDeclaration=function(a,b,c){c(a.source,b,"Expression")},q.ImportDeclaration=function(a,b,c){for(var d=0;d<a.specifiers.length;d++)c(a.specifiers[d],b);c(a.source,b,"Expression")},q.ImportSpecifier=q.ImportDefaultSpecifier=q.ImportNamespaceSpecifier=q.Identifier=q.Literal=o,q.TaggedTemplateExpression=function(a,b,c){c(a.tag,b,"Expression"),c(a.quasi,b)},q.ClassDeclaration=q.ClassExpression=function(a,b,c){return c(a,b,"Class")},q.Class=function(a,b,c){a.id&&c(a.id,b,"Pattern"),a.superClass&&c(a.superClass,b,"Expression");for(var d=0;d<a.body.body.length;d++)c(a.body.body[d],b)},q.MethodDefinition=q.Property=function(a,b,c){a.computed&&c(a.key,b,"Expression"),c(a.value,b,"Expression")},q.ComprehensionExpression=function(a,b,c){for(var d=0;d<a.blocks.length;d++)c(a.blocks[d].right,b,"Expression");c(a.body,b,"Expression")}},{}]},{},[1])(1)})}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],41:[function(a,b,c){function d(a){return a&&k.ArrayExpression===a.type}function e(a,b){return k.Identifier===a.type&&b===a.name}function f(a){return 1===a.length&&k.Literal===a[0].type?a[0].value:void 0}function g(a){var b,c,e;if(
// Handle define([], function() {}) format
d(a[0])?b=a[0].elements:d(a[1])&&(b=a[1].elements),b)for(c=0,e=b.length;e>c;c++)b[c]=b[c].value;return b}/**
 * Method to pull dependencies from a JavaScript source string.
 *
 * @param {string} source - Source to parse
 * @param {object} options - Options passed to acorn
 *
 * @returns {object:{array: dependencies}} - Object with dependencies
 */
function h(a,b){return h.walk(i.parse(a,b))}var i=a("acorn"),j=a("acorn-walk"),k={_define:"define",_require:"require",Identifier:"Identifier",Literal:"Literal",ArrayExpression:"ArrayExpression"};/**
 * Method to pull dependencies from an AST.
 *
 * @param {object} ast - AST to traverse in order to find all dependencies.
 *
 * @returns {object:{array: dependencies}} - Object with dependencies
 */
h.walk=function(a){function b(a){if(e(a.callee,k._require)){var b=f(a.arguments);b&&c.dependencies.push(b)}else if(e(a.callee,k._define)){var d=g(a.arguments);d&&d.length&&(c.dependencies=c.dependencies.concat(d))}}var c={dependencies:[]};return j.simple(a,{CallExpression:b}),c},b.exports=h},{acorn:39,"acorn-walk":40}],42:[function(a,b,c){/**
 * Method to process dependencies.
 *
 * @param {{source: source}} data - Object with `source` property to be
 *  processed for dependencies
 */
function d(a,b){return e(a,b)}function e(a,b){return f(a,g(a.source,b).dependencies)}function f(a,b){return b.length?{deps:a.deps.concat(b)}:void 0}var g=a("pulling-deps");/**
 * Method to configure a dependencies processor.
 *
 * @param {object} options - Configuration settings for processing dependencies
 *  This module uses [acorn]{@link http://marijnhaverbeke.nl/acorn/}, which is
 *  what the options are actually passed to.
 *
 * @returns {function} Delegate to be called with an object with a `source`
 *  property to pull the dependencies from.
 */
d.config=function(a){return function(b){return e(b,a)}},b.exports=d},{"pulling-deps":41}],43:[function(a,b,c){(function(a){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function b(a,b){for(var c=0,d=a.length-1;d>=0;d--){var e=a[d];"."===e?a.splice(d,1):".."===e?(a.splice(d,1),c++):c&&(a.splice(d,1),c--)}
// if the path is allowed to go above the root, restore leading ..s
if(b)for(;c--;c)a.unshift("..");return a}function d(a,b){if(a.filter)return a.filter(b);for(var c=[],d=0;d<a.length;d++)b(a[d],d,a)&&c.push(a[d]);return c}
// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var e=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,f=function(a){return e.exec(a).slice(1)};
// path.resolve([from ...], to)
// posix version
c.resolve=function(){for(var c="",e=!1,f=arguments.length-1;f>=-1&&!e;f--){var g=f>=0?arguments[f]:a.cwd();
// Skip empty and invalid entries
if("string"!=typeof g)throw new TypeError("Arguments to path.resolve must be strings");g&&(c=g+"/"+c,e="/"===g.charAt(0))}
// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)
// Normalize the path
return c=b(d(c.split("/"),function(a){return!!a}),!e).join("/"),(e?"/":"")+c||"."},
// path.normalize(path)
// posix version
c.normalize=function(a){var e=c.isAbsolute(a),f="/"===g(a,-1);
// Normalize the path
return a=b(d(a.split("/"),function(a){return!!a}),!e).join("/"),a||e||(a="."),a&&f&&(a+="/"),(e?"/":"")+a},
// posix version
c.isAbsolute=function(a){return"/"===a.charAt(0)},
// posix version
c.join=function(){var a=Array.prototype.slice.call(arguments,0);return c.normalize(d(a,function(a,b){if("string"!=typeof a)throw new TypeError("Arguments to path.join must be strings");return a}).join("/"))},
// path.relative(from, to)
// posix version
c.relative=function(a,b){function d(a){for(var b=0;b<a.length&&""===a[b];b++);for(var c=a.length-1;c>=0&&""===a[c];c--);return b>c?[]:a.slice(b,c-b+1)}a=c.resolve(a).substr(1),b=c.resolve(b).substr(1);for(var e=d(a.split("/")),f=d(b.split("/")),g=Math.min(e.length,f.length),h=g,i=0;g>i;i++)if(e[i]!==f[i]){h=i;break}for(var j=[],i=h;i<e.length;i++)j.push("..");return j=j.concat(f.slice(h)),j.join("/")},c.sep="/",c.delimiter=":",c.dirname=function(a){var b=f(a),c=b[0],d=b[1];
// It has a dirname, strip trailing slash
return c||d?(d&&(d=d.substr(0,d.length-1)),c+d):"."},c.basename=function(a,b){var c=f(a)[2];
// TODO: make this comparison case-insensitive on windows?
return b&&c.substr(-1*b.length)===b&&(c=c.substr(0,c.length-b.length)),c},c.extname=function(a){return f(a)[3]};
// String.prototype.substr - negative index don't work in IE8
var g="b"==="ab".substr(-1)?function(a,b,c){return a.substr(b,c)}:function(a,b,c){return 0>b&&(b=a.length+b),a.substr(b,c)}}).call(this,a("_process"))},{_process:44}],44:[function(a,b,c){function d(){k=!1,h.length?j=h.concat(j):l=-1,j.length&&e()}function e(){if(!k){var a=setTimeout(d);k=!0;for(var b=j.length;b;){for(h=j,j=[];++l<b;)h&&h[l].run();l=-1,b=j.length}h=null,k=!1,clearTimeout(a)}}
// v8 likes predictible objects
function f(a,b){this.fun=a,this.array=b}function g(){}
// shim for using process in browser
var h,i=b.exports={},j=[],k=!1,l=-1;i.nextTick=function(a){var b=new Array(arguments.length-1);if(arguments.length>1)for(var c=1;c<arguments.length;c++)b[c-1]=arguments[c];j.push(new f(a,b)),1!==j.length||k||setTimeout(e,0)},f.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",// empty string to avoid regexp issues
i.versions={},i.on=g,i.addListener=g,i.once=g,i.off=g,i.removeListener=g,i.removeAllListeners=g,i.emit=g,i.binding=function(a){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(a){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},{}],45:[function(a,b,c){function d(a){"string"==typeof a&&(a={url:a});var b=new XMLHttpRequest,c=a.url,h=a.method||"GET",i=a.data||null,j=a.headers||{},k=d.async;if(!c)throw new TypeError("Must provide a URL");return a.hasOwnProperty("withCredentials")&&(b.withCredentials=a.withCredentials),a.hasOwnProperty("timeout")&&(b.timeout=a.timeout),new Promise(function(l,m){function n(){var c=b.readyState;if(
// If there is a state change handler, call it with the request object and options.
a.stateChange&&a.stateChange(b,a),c===g.DONE)if(b.status>=100&&b.status<300){
// Handle response transformation.
var f=(a.transform||e)(b.responseText,b.getResponseHeader("Content-Type"));
// Call global success handler
d.success(f,b),a.success&&a.success(f,b),
// Resolve deferred Promise
l(f)}else
// Call global error handler
d.error(b),a.error&&a.error(b),
// Reject deferred Promise
m(b)}b.onreadystatechange=n,b.open(h,c,k,a.user,a.password),
// Make sure to add all the headers.
f(b,d.headers),f(b,j),b.send(i)})}function e(a,b){var c=d.transforms[b];return c?c(a):a}function f(a,b){for(var c in b)b.hasOwnProperty(c)&&a.setRequestHeader(c,b[c])}var g={UNSENT:0,// open()has not been called yet.
OPENED:1,// send()has not been called yet.
HEADERS_RECEIVED:2,// send() has been called, and headers and status are available.
LOADING:3,// Downloading; responseText holds partial data.
DONE:4};
// Setup global async to true. ONLY for debugging.
d.async=!0,
// Set default headers
d.headers={},
// Assign transforms to content types
d.transforms={},d.transforms["application/json"]=JSON.parse,
// Global handlers for error and success
d.error=function(){},d.success=function(){},b.exports=d},{}],46:[function(a,b,c){/**
 * Bitimports extends Bitloader's functionality to provide support for AMD and
 * CJS. It implements a fetch provider to load files from storage. It also adds
 * the `define` and `require` methods to facilitte defining and loading modules
 *
 * @class
 * @private
 * @lends Bitloader.prototype
 *
 * @param {Object} options - Configuration settings to create Bitimports
 *  instance.
 *  Please take a look over at [amd resolver]{@link https://github.com/MiguelCastillo/amd-resolver}
 *  for details on the options.
 * @param {string} options.baseUrl - Is the root URL that all modules are
 *  relative to.
 * @param {Object} options.paths - Is a map of module names to module locations
 *  This really useful for setting up module names that are more legible and
 *  easier to maintain.
 * @param {Array.<(string|Function|Object)>} options.transforms[] - Collection of
 *  transforms to be applied to module meta sources.
 * @param {string} options.transforms[] - Transform to be loaded as a named
 *  module.
 * @param {Function} options.transforms[] - Anonymous transformation that
 *  transforms module meta source.
 * @param {Object} options.transforms[] - More specific transform configuration
 *  where either a name or handler function must be provided.
 * @param {string} options.transforms[].name - If item.handler isn't present,
 *  then Bitimports will load the transform as a module. Otherwise, it is
 *  pretty much only used for logging purposes.
 * @param {Function} options.transforms[].handler - If item.name isn't present,
 *  then the handler is considered an anonymous transform, otherwise it is
 *  considered a named transformed. Named transforms are very useful when
 *  debugging because transforms' names are logged
 */
function d(a){var b=j.merge({},k,a),c=new f(b),d=new e(this,b);b.resolve=b.resolve||c.resolve.bind(c),b.fetch=b.fetch||d.fetch.bind(d),i.call(this,b),this.plugin("js",{dependency:h}),
// Make this option a bit obtuse - I wanna make it a lil difficult for people to
// enable processing of node_modules since it can be rather difficult to tweak
// configurations to properly excluce modules to be processed.
b.doNotIgnoreNodeModules!==!0&&this.services.dependency.ignore("path",/node_modules\//)}var e=a("./fetcher"),f=a("./resolver"),g=a("./logger"),h=a("deps-bits"),i=a("bit-loader"),j=a("belty"),k={baseUrl:".",paths:{},shim:{},deps:[],packages:[],transforms:[]};
// Setup prototypal inheritance.
d.prototype=Object.create(i.prototype),d.prototype.constructor=d,
// Add these contructs to the prototype so that bit import instances can have
// access to them.
d.prototype.logger=g,d.prototype.Module=i.Module,d.prototype.Rule=i.Rule,/**
 * Bitimports factory
 *
 * @returns {Bitimports} Instance of Bitimports
 */
d.prototype.create=function(a){return new d(a)},/**
 * Method to configure an instance of Bitimports.
 *
 * config applies the configuration settings to `this` instance of Bitimports.
 * It will also create and return a new instance of Bitimports with the
 * configuration settings passed in. The config method is generally your
 * primary way of configuring and creating instances of Bitimports.
 *
 * @param {Object} [options] - Configuration settings used for creating the
 *  instance of Bitimports.
 *
 * @returns {Bitimports} Instance of Bitimports
 */
d.prototype.config=function(a){return j.merge(this.settings,a),this.create(a)},/**
 * `bitimports` is the default Bitimports instance available. All you need to
 * do if configure it with the [config]{@link Bitimports#config} method to
 * define how your application is structured. The goal of the configuration
 * step is to help you make your code simple and readable when importing and
 * exporting modules.
 *
 * When the bit-imports module is loaded via script tag, which is the more
 * common use case in the browser, `bitimports` is automatically added to the
 * global object.  But since bit-imports is a [UMD]{@link https://github.com/umdjs/umd}
 * module, feel free to load it as an [AMD]{@link https://github.com/amdjs/amdjs-api/wiki/AMD}
 * or [CJS]{@link http://wiki.commonjs.org/wiki/Modules/1.1.1} module.
 *
 * `bitimports` exposes methods such as [require]{@link Bitimports#require},
 * [define]{@link Bitimports#define}, [import]{@link Bitimports#import}, and
 * [register]{@link Bitimports#register} to provide a comprehensive system for
 * loading modules synchronously and asynchronously in `AMD` and `CJS` module
 * formats.
 *
 * @global
 * @name bitimports
 * @type Bitimports
 * @see {@link Bitimports}
 */
b.exports=new d},{"./fetcher":47,"./logger":49,"./resolver":50,belty:7,"bit-loader":18,"deps-bits":42}],47:[function(a,b,c){/**
 * @class
 *
 * FileReader that loads files from storage
 */
function d(){}var e=a("./fileReader"),f=a("./logger").create("bitimports/fetch");/**
 * Reads file content from storage
 */
d.prototype.fetch=function(a){function b(a){return{source:a}}return f.log(a.name,a,location),e(a.path).then(b,f.error)},b.exports=d},{"./fileReader":48,"./logger":49}],48:[function(a,b,c){function d(a){f=a}function e(a){return f(a)}var f;e.register=d,b.exports=e},{}],49:[function(a,b,c){var d=a("bit-loader");b.exports=d.logger},{"bit-loader":18}],50:[function(a,b,c){function d(a){a=a||{},a.baseUrl=e(a.baseUrl),this._resolver=new g(a)}/*
 * This will adjust the baseUrl in the settings so that requests get the absolute
 * url so that browsers can better handle `# sourceURL`.  In chrome for example,
 * the files are added to the developer tools' source tree, which let's you put
 * break points directly from the developer tools.
 */
function e(a){var b="undefined"!=typeof window?window.location.href:"";return g.Url.parser.resolve(b,a||"")}/*
 * Gets the url form the module data if it exists.
 */
function f(a){return a&&a.path||""}var g=a("amd-resolver");d.prototype.resolve=function(a){var b=this._resolver.resolve(a.name,f(a.referrer)),c=g.File.parseParts(b.url.href);return b.directory=c.directory,b.path=c.path,b},b.exports=d},{"amd-resolver":3}]},{},[1])(1)});
//# sourceMappingURL=bit-imports.min.js.map