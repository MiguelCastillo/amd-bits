<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: node_modules/bit-loader/src/module.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-font.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body class="api-docs">

<div id="main">
    <h1 class="page-title">Source: node_modules/bit-loader/src/module.js</h1>
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var utils = require("belty");
var types = require("dis-isa");


/**
 * Module types.
 *
 * @deprecated
 * @ignore
 */
var Type = {
  "UNKNOWN" : "UNKNOWN",
  "AMD"     : "AMD",     //Asynchronous Module Definition
  "CJS"     : "CJS",     //CommonJS
  "IIFE"    : "IIFE"     //Immediately-Invoked Function Expression
};


/**
 * There are three states a module can be in, and each state can be in a different
 * stage. The different states are REGISTERED, LOADED, READY.
 *
 * &lt;pre>
 * REGISTERED has four stages before a module can be LOADED.
 *  1. RESOLVE.
 *  2. FETCH.
 *  3. TRANSFORM.
 *  4. DEPENDENCY.
 *
 * LOADED has two stages before a module can be READY.
 *  1. COMPILE.
 *  2. LINK.
 * &lt;/pre>
 *
 * READY is the final state and has no stages. When a module is READY,
 * it can be consumed by the host application.
 *
 * @enum
 * @memberof Module
 */
var State = {
  REGISTERED: 0,
    RESOLVE: 1,
    FETCH:  2,
    TRANSFORM: 3,
    DEPENDENCY: 4,
  LOADED: 5,
    COMPILE: 6,
    LINK: 7,
  READY: 8
};


/**
 * Module class definition. This contains all information used in the processed
 * of creating the module as well as the data the host application consumes. Perhaps
 * the single most important piece of information is `exports`, which is ultimately
 * the piece of data that the host application consumes.
 *
 * @class
 *
 * @property {string} id - Module id
 * @property {string} name - Module name
 * @property {string[]} deps - Array of module dependencies
 * @property {function} factory - Function that generates the data a particular module exports
 * @property {any} exports - Data exported by a module
 */
function Module(options) {
  if (!options) {
    throw new TypeError("Must provide options to create the module");
  }

  if (options.hasOwnProperty("exports")) {
    this.exports = options.exports;
  }

  if (options.hasOwnProperty("factory")) {
    this.factory = options.factory;
  }

  this.type = options.type || Type.UNKNOWN;
  this.id = options.id || options.name;
  this.name = options.name;
  this.deps = options.deps ? options.deps.slice(0) : [];
}


/**
 * Module meta class definition. This is an intermediary representation of the processed
 * module information before a proper Module instance is created. This is what all pipelines
 * interact with before the build stage creates a Module instance.
 *
 * @class
 * @memberof Module
 */
function Meta(options) {
  options = options || {};

  if (types.isString(options)) {
    options = {
      name: options
    };
  }

  if (!types.isString(options.name)) {
    throw new TypeError("Must provide a name, which is used by the resolver to resolve the path for the resource");
  }

  this.deps = [];
  mergeConfiguration(this, options);
}


/**
 * Returns the directory part of a file path.
 */
Meta.prototype.getDirectory = function() {
  return this.directory || "";
};


/**
 * Returns the file name of the file path.
 */
Meta.prototype.getFileName = function() {
  return this.fileName || "";
};


/**
 * Returns the file path, which is the full path for the file in storage.
 */
Meta.prototype.getFilePath = function() {
  return this.path || "";
};


/**
 * Safely merges data into the instance of module meta. This returns a new instance
 * to keep the module meta object as immutable as possible.
 *
 * @param {object} options - Options to merge into the module meta instance.
 *
 * @returns {Meta} New module meta instance with the aggregated options merged in.
 */
Meta.prototype.configure = function(options) {
  // Provide immutability to prevent side effects
  return mergeConfiguration(new Meta(this), options);
};


/**
 * Verifies that a module meta object is either already compiled or can be compiled.
 *
 * @param {Meta} moduleMeta - Module meta instance.
 *
 * @returns {boolean}
 */
Meta.validate = function(moduleMeta) {
  if (!moduleMeta) {
    throw new TypeError("Must provide options");
  }

  if (!Meta.isCompiled(moduleMeta) &amp;&amp; !Meta.canCompile(moduleMeta)) {
    throw new TypeError("ModuleMeta must provide a `source` string or `exports`.");
  }
};


/**
 * Verifies if a module meta object has dependencies.
 *
 * @param {Meta} moduleMeta - Module meta instance.
 *
 * @returns {boolean}
 */
Meta.hasDependencies = function(moduleMeta) {
  return moduleMeta.deps.length;
};


/**
 * A module meta object is considered compiled if it has a `exports` or `factory` method.
 * That's because those are the two things that the compile step actually generates
 * before creating a Module instance.
 *
 * @param {Meta} moduleMeta - Module meta instance.
 *
 * @returns {boolean}
 */
Meta.isCompiled = function(moduleMeta) {
  return moduleMeta.hasOwnProperty("exports") || types.isFunction(moduleMeta.factory);
};


/**
 * Checks if the module meta object can be compiled by verifying that it has NOT
 * already been compiled and that it has a `source` property that need to be compiled.
 *
 * @param {Meta} moduleMeta - Module meta instance.
 *
 * @returns {boolean}
 */
Meta.canCompile = function(moduleMeta) {
  return !Meta.isCompiled(moduleMeta) &amp;&amp; types.isString(moduleMeta.source);
};


/**
 * Merges in options into a module meta object
 *
 * @ignore
 */
function mergeConfiguration(moduleMeta, options) {
  options = options || {};
  var result = utils.extend(moduleMeta, options);

  if (options.deps) {
    result.deps = options.deps.slice(0);
  }

  if (options.path) {
    result.directory = parseDirectoryFromPath(options.path);
    result.fileName = parseFileNameFromPath(options.path);
  }

  return result;
}


function parseDirectoryFromPath(path) {
  return (path || "").replace(/([^/\\]+)$/gmi, "");
}


function parseFileNameFromPath(path) {
  var fileName = /[^/\\]+$/gmi.exec(path || "");
  return fileName ? fileName[0] : "";
}


Module.Meta  = Meta;
Module.Type  = Type;
Module.State = State;
module.exports = Module;
</code></pre>
        </article>
    </section>




</div>

<nav id="side-nav">
    <h3><a href="global.html">global</a></h3><ul><li><a href="global.html#bitimports">bitimports</a></li></ul><h3><a href="Bitimports.html">Bitimports</a></h3><ul><li><a href="Bitimports.html#clear">clear</a></li><li><a href="Bitimports.html#configure">configure</a></li><li><a href="Bitimports.html#create">create</a></li><li><a href="Bitimports.html#deleteModule">deleteModule</a></li><li><a href="Bitimports.html#exclude">exclude</a></li><li><a href="Bitimports.html#fetch">fetch</a></li><li><a href="Bitimports.html#fetchOnly">fetchOnly</a></li><li><a href="Bitimports.html#getModule">getModule</a></li><li><a href="Bitimports.html#getSource">getSource</a></li><li><a href="Bitimports.html#hasModule">hasModule</a></li><li><a href="Bitimports.html#ignore">ignore</a></li><li><a href="Bitimports.html#import">import</a></li><li><a href="Bitimports.html#isExcluded">isExcluded</a></li><li><a href="Bitimports.html#load">load</a></li><li><a href="Bitimports.html#logger">logger</a></li><li><a href="Bitimports.html#plugin">plugin</a></li><li><a href="Bitimports.html#register">register</a></li><li><a href="Bitimports.html#resolve">resolve</a></li><li><a href="Bitimports.html#transform">transform</a></li></ul><h3><a href="Module.html">Module</a></h3><ul><li><a href="Module.Meta.html">Meta</a></li><li><a href="Module.html#.State">State</a></li></ul><h3><a href="Module.Meta.html">Module Meta</a></h3><ul><li><a href="Module.Meta.html#.canCompile">canCompile</a></li><li><a href="Module.Meta.html#.hasDependencies">hasDependencies</a></li><li><a href="Module.Meta.html#.isCompiled">isCompiled</a></li><li><a href="Module.Meta.html#.validate">validate</a></li><li><a href="Module.Meta.html#configure">configure</a></li><li><a href="Module.Meta.html#getDirectory">getDirectory</a></li><li><a href="Module.Meta.html#getFileName">getFileName</a></li><li><a href="Module.Meta.html#getFilePath">getFilePath</a></li></ul><h3><a href="Module.html#.State">Module State</a></h3><ul><li><a href="Module.html#.State#.COMPILE">COMPILE</a></li><li><a href="Module.html#.State#.DEPENDENCY">DEPENDENCY</a></li><li><a href="Module.html#.State#.FETCH">FETCH</a></li><li><a href="Module.html#.State#.LINK">LINK</a></li><li><a href="Module.html#.State#.LOADED">LOADED</a></li><li><a href="Module.html#.State#.READY">READY</a></li><li><a href="Module.html#.State#.REGISTERED">REGISTERED</a></li><li><a href="Module.html#.State#.RESOLVE">RESOLVE</a></li><li><a href="Module.html#.State#.TRANSFORM">TRANSFORM</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Jun 06 2016 21:25:48 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
